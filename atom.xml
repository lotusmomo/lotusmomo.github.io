<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落寒陌墨の隠し部屋</title>
  
  
  <link href="https://blog.lotusmomo.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lotusmomo.cn/"/>
  <updated>2025-03-16T09:10:20.112Z</updated>
  <id>https://blog.lotusmomo.cn/</id>
  
  <author>
    <name>落寒陌墨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移除过时的 zfs-import 服务</title>
    <link href="https://blog.lotusmomo.cn/2025/03/15/remove-deprecated-zfs-import-service/"/>
    <id>https://blog.lotusmomo.cn/2025/03/15/remove-deprecated-zfs-import-service/</id>
    <published>2025-03-15T06:05:31.000Z</published>
    <updated>2025-03-16T09:10:20.112Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候我们已经删除了某个 zfs 存储池，但是 zfs-import 服务仍然尝试在系统启动时导入它。本文记录了如何移除这种过时的 zfs-import 服务。</p><span id="more"></span><p>使用 <code>journalctl</code> 命令查看 systemd 的日志，找出目标服务。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@pve01 ~ % journalctl -r | grep HDPool</span><br><span class="line">Mar <span class="number">15</span> <span class="number">13</span>:<span class="number">58</span>:<span class="number">20</span> pve01 systemd[<span class="number">1</span>]: Failed <span class="keyword">to</span> start zfs-<span class="keyword">import</span>@HDPool01.service - Import ZFS pool HDPool01.</span><br><span class="line">Mar <span class="number">15</span> <span class="number">13</span>:<span class="number">58</span>:<span class="number">20</span> pve01 systemd[<span class="number">1</span>]: zfs-<span class="keyword">import</span>@HDPool01.service: Failed <span class="keyword">with</span> result <span class="string">&#x27;exit-code&#x27;</span>.</span><br><span class="line">Mar <span class="number">15</span> <span class="number">13</span>:<span class="number">58</span>:<span class="number">20</span> pve01 systemd[<span class="number">1</span>]: zfs-<span class="keyword">import</span>@HDPool01.service: Main process exited, code=exited, status=<span class="number">1</span>/FAILURE</span><br><span class="line">Mar <span class="number">15</span> <span class="number">13</span>:<span class="number">58</span>:<span class="number">20</span> pve01 zpool[<span class="number">2193</span>]: cannot <span class="keyword">import</span> <span class="string">&#x27;HDPool01&#x27;</span>: <span class="literal">no</span> such pool available</span><br><span class="line">Mar <span class="number">15</span> <span class="number">13</span>:<span class="number">58</span>:<span class="number">20</span> pve01 systemd[<span class="number">1</span>]: Starting zfs-<span class="keyword">import</span>@HDPool01.service - Import ZFS pool HDPool01...</span><br><span class="line">Feb <span class="number">28</span> <span class="number">15</span>:<span class="number">46</span>:<span class="number">15</span> pve01 systemd[<span class="number">1</span>]: Failed <span class="keyword">to</span> start zfs-<span class="keyword">import</span>@HDPool01.service - Import ZFS pool HDPool01.</span><br><span class="line">Feb <span class="number">28</span> <span class="number">15</span>:<span class="number">46</span>:<span class="number">15</span> pve01 systemd[<span class="number">1</span>]: zfs-<span class="keyword">import</span>@HDPool01.service: Failed <span class="keyword">with</span> result <span class="string">&#x27;exit-code&#x27;</span>.</span><br><span class="line">Feb <span class="number">28</span> <span class="number">15</span>:<span class="number">46</span>:<span class="number">15</span> pve01 systemd[<span class="number">1</span>]: zfs-<span class="keyword">import</span>@HDPool01.service: Main process exited, code=exited, status=<span class="number">1</span>/FAILURE</span><br><span class="line">Feb <span class="number">28</span> <span class="number">15</span>:<span class="number">46</span>:<span class="number">15</span> pve01 zpool[<span class="number">280083</span>]: cannot <span class="keyword">import</span> <span class="string">&#x27;HDPool01&#x27;</span>: <span class="literal">no</span> such pool available</span><br><span class="line">Feb <span class="number">28</span> <span class="number">15</span>:<span class="number">46</span>:<span class="number">15</span> pve01 systemd[<span class="number">1</span>]: Starting zfs-<span class="keyword">import</span>@HDPool01.service - Import ZFS pool HDPool01...</span><br><span class="line">Jan <span class="number">13</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">17</span> pve01 systemd[<span class="number">1</span>]: Failed <span class="keyword">to</span> start zfs-<span class="keyword">import</span>@HDPool01.service - Import ZFS pool HDPool01.</span><br><span class="line">Jan <span class="number">13</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">17</span> pve01 systemd[<span class="number">1</span>]: zfs-<span class="keyword">import</span>@HDPool01.service: Failed <span class="keyword">with</span> result <span class="string">&#x27;exit-code&#x27;</span>.</span><br><span class="line">Jan <span class="number">13</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">17</span> pve01 systemd[<span class="number">1</span>]: zfs-<span class="keyword">import</span>@HDPool01.service: Main process exited, code=exited, status=<span class="number">1</span>/FAILURE</span><br><span class="line">Jan <span class="number">13</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">17</span> pve01 zpool[<span class="number">2253</span>]: cannot <span class="keyword">import</span> <span class="string">&#x27;HDPool01&#x27;</span>: <span class="literal">no</span> such pool available</span><br><span class="line">Jan <span class="number">13</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">17</span> pve01 systemd[<span class="number">1</span>]: Starting zfs-<span class="keyword">import</span>@HDPool01.service - Import ZFS pool HDPool01...</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p><code>HDPool01</code> ZFS 池已经删除，但 <code>systemd</code> 仍然尝试导入它，导致 <code>zfs-import@HDPool01.service</code> 失败。可以通过以下步骤清理这个残留的 systemd 服务：</p><h1>检查 systemd 服务状态</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@pve01 ~ % systemctl status zfs-import@HDPool01.service </span><br><span class="line"></span><br><span class="line">× zfs-import@HDPool01.service - Import ZFS<span class="built_in"> pool </span>HDPool01</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/zfs-import@.service; enabled; preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Sat 2025-03-15 13:58:20 CST; 4min 27s ago</span><br><span class="line">       Docs: man:zpool(8)</span><br><span class="line">    Process: 2193 <span class="attribute">ExecStart</span>=/sbin/zpool import -N -d /dev/disk/by-id -o <span class="attribute">cachefile</span>=none HDPool01 (<span class="attribute">code</span>=exited, <span class="attribute">status</span>=1/FAILURE)</span><br><span class="line">   Main PID: 2193 (<span class="attribute">code</span>=exited, <span class="attribute">status</span>=1/FAILURE)</span><br><span class="line">        CPU: 87ms</span><br><span class="line"></span><br><span class="line">Mar 15 13:58:20 pve01 systemd[1]: Starting zfs-import@HDPool01.service - Import ZFS<span class="built_in"> pool </span>HDPool01<span class="built_in">..</span>.</span><br><span class="line">Mar 15 13:58:20 pve01 zpool[2193]: cannot import <span class="string">&#x27;HDPool01&#x27;</span>: <span class="literal">no</span> such<span class="built_in"> pool </span>available</span><br><span class="line">Mar 15 13:58:20 pve01 systemd[1]: zfs-import@HDPool01.service: Main process exited, <span class="attribute">code</span>=exited, <span class="attribute">status</span>=1/FAILURE</span><br><span class="line">Mar 15 13:58:20 pve01 systemd[1]: zfs-import@HDPool01.service: Failed with result <span class="string">&#x27;exit-code&#x27;</span>.</span><br><span class="line">Mar 15 13:58:20 pve01 systemd[1]: Failed <span class="keyword">to</span> start zfs-import@HDPool01.service - Import ZFS<span class="built_in"> pool </span>HDPool01.</span><br></pre></td></tr></table></figure><p>显示 <code>enabled</code>，说明它仍然会在启动时尝试加载。</p><h1>禁用并停止该服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> zfs-import@HDPool01.service</span><br><span class="line">systemctl stop zfs-import@HDPool01.service</span><br></pre></td></tr></table></figure><h1>检查并移除 <code>zfs-import-cache</code></h1><p>ZFS 可能仍然缓存了旧的池信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /etc/zfs/zpool.cache</span><br></pre></td></tr></table></figure><p>然后重新生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zpool <span class="built_in">set</span> cachefile=/etc/zfs/zpool.cache $(zpool list -Ho name)</span><br></pre></td></tr></table></figure><p>如果 <code>zpool list</code> 没有输出，那说明已经没有可用的池了，可以跳过这一步。</p><h1>重启 <code>zfs-import.target</code></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart zfs-import.target</span><br></pre></td></tr></table></figure><h1>检查 systemd 依赖项</h1><p>有时 <code>zfs-import@HDPool01.service</code> 可能是其他服务的依赖项，查看所有相关 ZFS 服务：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@pve01 /etc/zfs % systemctl list-units --<span class="keyword">type</span>=service | grep zfs</span><br><span class="line"></span><br><span class="line">  zfs-<span class="keyword">import</span>-cache.service                              loaded active exited  <span class="keyword">Import</span> ZFS pools by cache <span class="keyword">file</span></span><br><span class="line">  zfs-<span class="keyword">import</span>-<span class="built_in">scan</span>.service                               loaded active exited  <span class="keyword">Import</span> ZFS pools by device scanning</span><br><span class="line">● zfs-<span class="keyword">import</span>@HDPool01.service                           loaded failed failed  <span class="keyword">Import</span> ZFS pool HDPool01</span><br><span class="line">  zfs-<span class="keyword">import</span>@tank.service                               loaded active exited  <span class="keyword">Import</span> ZFS pool tank</span><br><span class="line">  zfs-mount.service                                     loaded active exited  Mount ZFS filesystems</span><br><span class="line">  zfs-share.service                                     loaded active exited  ZFS <span class="keyword">file</span> system shares</span><br><span class="line">  zfs-volume-<span class="keyword">wait</span>.service                               loaded active exited  <span class="keyword">Wait</span> for ZFS Volume (zvol) links <span class="keyword">in</span> /dev</span><br><span class="line">  zfs-zed.service                                       loaded active running ZFS Event Daemon (zed)</span><br></pre></td></tr></table></figure><p>如果 <code>zfs.target</code> 仍然依赖 <code>HDPool01</code>，可以尝试重新加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl reset-failed</span><br></pre></td></tr></table></figure><h1>再次确认 systemd 依赖项</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@pve01 /etc/zfs % systemctl list-units --<span class="keyword">type</span>=service | grep zfs</span><br><span class="line"></span><br><span class="line">  zfs-<span class="keyword">import</span>-cache.service                              loaded active     exited        <span class="keyword">Import</span> ZFS pools by cache <span class="keyword">file</span></span><br><span class="line">  zfs-<span class="keyword">import</span>-<span class="built_in">scan</span>.service                               loaded active     exited        <span class="keyword">Import</span> ZFS pools by device scanning</span><br><span class="line">  zfs-<span class="keyword">import</span>@tank.service                               loaded active     exited        <span class="keyword">Import</span> ZFS pool tank</span><br><span class="line">  zfs-mount.service                                     loaded active     exited        Mount ZFS filesystems</span><br><span class="line">  zfs-share.service                                     loaded active     exited        ZFS <span class="keyword">file</span> system shares</span><br><span class="line">  zfs-volume-<span class="keyword">wait</span>.service                               loaded active     exited        <span class="keyword">Wait</span> for ZFS Volume (zvol) links <span class="keyword">in</span> /dev</span><br><span class="line">  zfs-zed.service                                       loaded active     running       ZFS Event Daemon (zed)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有的时候我们已经删除了某个 zfs 存储池，但是 zfs-import 服务仍然尝试在系统启动时导入它。本文记录了如何移除这种过时的 zfs-import 服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.lotusmomo.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>基于 PYNQ-Z2 的 HDMI 开发系列 01 - 输出测试图</title>
    <link href="https://blog.lotusmomo.cn/2025/03/11/pynq-z2-tpg/"/>
    <id>https://blog.lotusmomo.cn/2025/03/11/pynq-z2-tpg/</id>
    <published>2025-03-11T15:11:25.000Z</published>
    <updated>2025-03-16T09:10:20.110Z</updated>
    
    <content type="html"><![CDATA[<p>本系列为 ZYNQ7000 视频处理的第一篇博客。该系列准备介绍一下 FPGA 上的视频处理流程。</p><span id="more"></span><h1>创建 Block Design</h1><p><img src="block-design.svg" alt="block-design"></p><p>双击 ZYNQ7 处理器系统 IP 进行配置。在“Clock Configuration”部分的“PL Fabric Clocks”下,启用 FCLK_CLK1 并将其时钟频率设置为 40 MHz。</p><p>添加 Video Timing Controller (VTC) IP 并双击打开其配置 GUI。<br>在“Detection/Generation”标签中，单击“Include AXI4-Lite Interface”并取消单击“Enable Detection”。<br>在“Default/Constant”标签中，将视频模式设定为 1280x720p。</p><p>双击 rgb2dvi IP 进行配置。将 TMDS 的时钟范围更改为“&lt;80 MHz (720p)”，然后单击“OK”。</p><h1>管脚约束</h1><p>略。官网有文档：<a href="https://www.tulembedded.com/FPGA/ProductsPYNQ-Z2.html">https://www.tulembedded.com/FPGA/ProductsPYNQ-Z2.html</a></p><p>然后生成 Bitstream, 导出包含 Bitstream 的工程。</p><h1>软件部分</h1><p>从 Vivado 启动 Vitis, 并选择我们刚刚导出的工程，创建一个 Helloworld。</p><p>修改代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;platform.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xv_tpg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">XV_tpg tpg_inst;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init_platform();</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Hello World\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TPG Initialization */</span></span><br><span class="line">    Status = XV_tpg_Initialize(&amp;tpg_inst, XPAR_V_TPG_0_DEVICE_ID);</span><br><span class="line">    <span class="keyword">if</span>(Status!= XST_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        xil_printf(<span class="string">&quot;TPG configuration failed\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(XST_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Resolution to 1280x720</span></span><br><span class="line">    XV_tpg_Set_height(&amp;tpg_inst, <span class="number">720</span>);</span><br><span class="line">    XV_tpg_Set_width(&amp;tpg_inst, <span class="number">1280</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Color Space to RGB</span></span><br><span class="line">    XV_tpg_Set_colorFormat(&amp;tpg_inst, <span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set pattern to color bar</span></span><br><span class="line">    XV_tpg_Set_bckgndId(&amp;tpg_inst, XTPG_BKGND_COLOR_BARS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Start the TPG</span></span><br><span class="line">    XV_tpg_EnableAutoRestart(&amp;tpg_inst);</span><br><span class="line">    XV_tpg_Start(&amp;tpg_inst);</span><br><span class="line">    xil_printf(<span class="string">&quot;TPG started!\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* End of TPG code*/</span></span><br><span class="line"></span><br><span class="line">    cleanup_platform();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行，此时会把 Bitstream 下载到 FPGA。</p><h1>观察现象</h1><p>串口会输出，此时显示器会显示彩条的 Test Pattern。</p><p><img src="output.png" alt="output"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本系列为 ZYNQ7000 视频处理的第一篇博客。该系列准备介绍一下 FPGA 上的视频处理流程。&lt;/p&gt;</summary>
    
    
    
    <category term="FPGA 入门" scheme="https://blog.lotusmomo.cn/categories/FPGA-%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>小米路由器 WR30U 刷入 OpenWRT</title>
    <link href="https://blog.lotusmomo.cn/2025/02/19/WR30U/"/>
    <id>https://blog.lotusmomo.cn/2025/02/19/WR30U/</id>
    <published>2025-02-19T09:04:00.000Z</published>
    <updated>2025-02-23T15:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>WR30U 是小米为中国联通定制的一款家用路由器，采用了联发科 MT7981B SoC，其无线规格支持 802.11ax/ac/n/g/a/b 2x2 MIMO，具有 128MB NAND 闪存以及 256MB DRAM，做工、散热、信号均属于上乘。本文教大家如何给这款路由器刷入 OpenWrt 系统，解锁更多强大功能。</p><span id="more"></span><h2 id="开启-SSH">开启 SSH</h2><p>由于是运营商定制的路由器，小米在固件中内置了一个 elink 服务以提供家庭自动化的相关功能。如果用户使用运营商提供的光猫作为一级网关，该服务会与网关的 32768 端口建立 TCP 连接来将自身注册到网关。</p><p>该服务在系统升级时会使用 <code>wget %s -O /tmp/update.bin</code> 下载更新固件，但是它不会检查 URL 地址是否有效。因此，如果我们输入 <code>;reboot;</code> 作为地址，它将执行我们的命令（在本例中为“reboot”）。</p><p>藉由该漏洞，我们可以实现该路由器上的 ACE（任意代码执行）。已经有开发者提供了该漏洞的利用工具：<br><a href="https://github.com/PatriciaLee3/wr30u_ssh">https://github.com/PatriciaLee3/wr30u_ssh</a><br>只要按照说明即可开启 SSH。</p><h2 id="备份分区">备份分区</h2><p>连接上 SSH 后运行以下命令以备份原厂固件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nanddump -f /tmp/tmp/BL2.bin /dev/mtd1</span><br><span class="line">nanddump -f /tmp/tmp/Nvram.bin /dev/mtd2</span><br><span class="line">nanddump -f /tmp/tmp/Bdata.bin /dev/mtd3</span><br><span class="line">nanddump -f /tmp/tmp/Factory.bin /dev/mtd4</span><br><span class="line">nanddump -f /tmp/tmp/FIP.bin /dev/mtd5</span><br><span class="line">nanddump -f /tmp/tmp/ubi.bin /dev/mtd8</span><br><span class="line">nanddump -f /tmp/tmp/KF.bin /dev/mtd12</span><br></pre></td></tr></table></figure><p>然后用 scp 保存到一个安全的地方。</p><h2 id="设定-U-Boot-参数并刷入临时镜像">设定 U-Boot 参数并刷入临时镜像</h2><blockquote><p>以下文件名均省略前缀，并默认你会用 scp 上传到路由器的 <code>/tmp/tmp</code> 目录。</p></blockquote><p>小米的路由器采用双分区布局，分别保存在 nand 的<code>ubi</code>和<code>ubi1</code>分区中，类似 Android 的 A/B 分区。运行命令<code>cat /proc/cmdline</code>查看当前的内核命令行就可以确认当前是从哪个分区启动。我们的目的是要把  OpenWRT  的安装镜像写入另一个分区，并在下次启动时切换为从该分区启动。</p><p>如果命令的输出中包含<code>firmware=0</code>或者<code>mtd=ubi</code>，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nvram <span class="built_in">set</span> boot_wait=on</span><br><span class="line">nvram <span class="built_in">set</span> uart_en=1</span><br><span class="line">nvram <span class="built_in">set</span> flag_boot_rootfs=1</span><br><span class="line">nvram <span class="built_in">set</span> flag_last_success=1</span><br><span class="line">nvram <span class="built_in">set</span> flag_boot_success=1</span><br><span class="line">nvram <span class="built_in">set</span> flag_try_sys1_failed=0</span><br><span class="line">nvram <span class="built_in">set</span> flag_try_sys2_failed=0</span><br><span class="line">nvram commit</span><br><span class="line">ubiformat /dev/mtd9 -y -f /tmp/tmp/stock-initramfs-factory.ubi</span><br></pre></td></tr></table></figure><p>如果命令的输出中包含<code>firmware=1</code>或者<code>mtd=ubi1</code>，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nvram <span class="built_in">set</span> boot_wait=on</span><br><span class="line">nvram <span class="built_in">set</span> uart_en=1</span><br><span class="line">nvram <span class="built_in">set</span> flag_boot_rootfs=0</span><br><span class="line">nvram <span class="built_in">set</span> flag_last_success=0</span><br><span class="line">nvram <span class="built_in">set</span> flag_boot_success=1</span><br><span class="line">nvram <span class="built_in">set</span> flag_try_sys1_failed=0</span><br><span class="line">nvram <span class="built_in">set</span> flag_try_sys2_failed=0</span><br><span class="line">nvram commit</span><br><span class="line">ubiformat /dev/mtd8 -y -f /tmp/tmp/stock-initramfs-factory.ubi</span><br></pre></td></tr></table></figure><p>重启路由器，将电脑的 IP 设定为<code>192.168.1.254</code>，掩码<code>255.255.255.0</code>。使用 SSH 连接 <code>192.168.1.1</code> 并执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysupgrade -n /tmp/tmp/stock-squashfs-sysupgrade.bin</span><br></pre></td></tr></table></figure><p>SSH 连接会自动断开并重启，OpenWRT 已经刷入成功了。</p><h2 id="刷入大分区固件">刷入大分区固件</h2><p>如果你想保留原始固件分区布局，就不要执行下面的步骤了。SSH 连接已经刷入 OpenWRT 的路由器，执行<code>cat /proc/mtd</code>查看当前的分区布局。输入应该包含以下的结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mtd7</span>: <span class="number">00040000</span> <span class="number">00020000</span> <span class="string">&quot;KF&quot;</span></span><br><span class="line"><span class="attribute">mtd8</span>: <span class="number">02200000</span> <span class="number">00020000</span> <span class="string">&quot;ubi_kernel&quot;</span></span><br><span class="line"><span class="attribute">mtd9</span>: <span class="number">04</span>e00000 <span class="number">00020000</span> <span class="string">&quot;ubi&quot;</span></span><br></pre></td></tr></table></figure><p>如果你的 <code>mtd8</code>，<code>mtd9</code>的参数与我提供的不一致，就不要继续操作了，以免变砖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubiformat /dev/mtd8 -y -f /tmp/ubootmod-initramfs-factory.ubi</span><br></pre></td></tr></table></figure><p>重启。</p><p>执行<code>cat /proc/mtd</code>查看当前的分区布局。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mtd7</span>: <span class="number">00040000</span> <span class="number">00020000</span> <span class="string">&quot;KF&quot;</span></span><br><span class="line"><span class="attribute">mtd8</span>: <span class="number">07000000</span> <span class="number">00020000</span> <span class="string">&quot;ubi&quot;</span></span><br></pre></td></tr></table></figure><p>务必确认<code>mtd8</code>为 ubi。</p><p>解锁 mtd 分区。执行以下命令安装内核模块<code>kmod-mtd-rw</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update &amp;&amp; opkg install kmod-mtd-rw</span><br></pre></td></tr></table></figure><p>如果不方便联网，就自己去 OpenWRT的包源上下一个，比如<a href="https://mirrors.nju.edu.cn/immortalwrt/releases/24.10.0/targets/mediatek/filogic/kmods/6.6.73-1-5dc876ca3b3685f0643c2f2c902f7b0b/kmod-mtd-rw_6.6.73.2021.02.28~e8776739-r1_aarch64_cortex-a53.ipk%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%90%E8%A1%8C%EF%BC%9A">https://mirrors.nju.edu.cn/immortalwrt/releases/24.10.0/targets/mediatek/filogic/kmods/6.6.73-1-5dc876ca3b3685f0643c2f2c902f7b0b/kmod-mtd-rw_6.6.73.2021.02.28~e8776739-r1_aarch64_cortex-a53.ipk，然后运行：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install /tmp/tmp/kmod-mtd-rw*.ipk --nodeps</span><br></pre></td></tr></table></figure><p>最后 启用内核模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod /lib/modules/$(<span class="built_in">uname</span> -r)/mtd-rw.ko i_want_a_brick=1</span><br></pre></td></tr></table></figure><p>执行<code>dmesg</code>查看内核消息，mtd-rw 将会把所有 mtd 分区标记为可写。</p><p>删除内核崩溃日志，否则路由器会陷入循环重启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /sys/fs/pstore/*</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;WR30U 是小米为中国联通定制的一款家用路由器，采用了联发科 MT7981B SoC，其无线规格支持 802.11ax/ac/n/g/a/b 2x2 MIMO，具有 128MB NAND 闪存以及 256MB DRAM，做工、散热、信号均属于上乘。本文教大家如何给这款路由器刷入 OpenWrt 系统，解锁更多强大功能。&lt;/p&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>贝尔 EA0326GMP 刷官方 ImmortalWrt 教程</title>
    <link href="https://blog.lotusmomo.cn/2024/11/27/NBEL/"/>
    <id>https://blog.lotusmomo.cn/2024/11/27/NBEL/</id>
    <published>2024-11-27T06:30:00.000Z</published>
    <updated>2024-11-27T06:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>贝尔 EA0326GMP 是一款中国移动定制的WiFi 6 路由器，采用喜闻乐见的 MT7981B 方案，具有 128MB NAND 与 256MB DDR，无线规格为 2x2 MIMO AX3000。由于其优良的硬件规格与低廉的价格，该路由器具备了一定的可玩性与折腾价值。</p><p>本教程旨在提供一个刷写官方OpenWrt/ImmortalWrt与其ubootmod的方法，为喜欢使用OpenWrt/ImmortalWrt opkg 生态的用户提供参考。</p><span id="more"></span><p>原始教程在：<a href="https://git.openwrt.org/?p=openwrt/openwrt.git;a=commit;h=40e7fab9e4a294882f198cb7fb5bc5eecee26ac8%EF%BC%8Ccommit">https://git.openwrt.org/?p=openwrt/openwrt.git;a=commit;h=40e7fab9e4a294882f198cb7fb5bc5eecee26ac8，commit</a> message 为具体步骤。</p><h1>解锁SSH</h1><p>首先下载配置文件：<a href="https://firmware.download.immortalwrt.eu.org/cnsztl/mediatek/filogic/openwrt-mediatek-mt7981-nokia-ea0326gmp-enable-ssh.tar.gz%E3%80%82">https://firmware.download.immortalwrt.eu.org/cnsztl/mediatek/filogic/openwrt-mediatek-mt7981-nokia-ea0326gmp-enable-ssh.tar.gz。</a></p><p>将电脑网卡 IP 设为<code>192.168.10.100</code>，子网掩码<code>24</code>即<code>255.255.255.0</code>。登录路由器后台<code>192.168.10.1</code>，导入刚刚下载的配置文件。</p><p>导入完成后，你会发现web界面登不上了，密码总是错误，不过这已经不重要了。此时已经可以通过ssh连接到路由器。</p><h1>备份 SPI NAND</h1><p>在路由器原厂系统环境（以下简称stock固件）下查看SPI分区表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/mtd</span></span><br><span class="line">dev:    size   erasesize  name</span><br><span class="line">mtd0: 08000000 00020000 &quot;spi0.0&quot;</span><br><span class="line">mtd1: 00100000 00020000 &quot;BL2&quot;</span><br><span class="line">mtd2: 00080000 00020000 &quot;u-boot-env&quot;</span><br><span class="line">mtd3: 00200000 00020000 &quot;Factory&quot;</span><br><span class="line">mtd4: 00200000 00020000 &quot;FIP&quot;</span><br><span class="line">mtd5: 00200000 00020000 &quot;Config&quot;</span><br><span class="line">mtd6: 00200000 00020000 &quot;Config2&quot;</span><br><span class="line">mtd7: 00c00000 00020000 &quot;Aos-net&quot;</span><br><span class="line">mtd8: 00c00000 00020000 &quot;bvasPlugin&quot;</span><br><span class="line">mtd9: 05680000 00020000 &quot;ubi&quot;</span><br></pre></td></tr></table></figure><p>因为已经把整个 SPI NAND 映射到<code>mtd0</code>，所以只要备份<code>mtd0</code>就行了。由于stock固件可用内存过小，强行备份会oom，所以选择使用TCP发送数据，PC端上位机接收来备份。</p><p>因为路由器自带的busybox是阉割版，没有netcat，所以我们下一个静态链接的arm64 busybox： <a href="https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-armv8l">https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-armv8l</a> ，用<code>scp</code>传到路由器的<code>/tmp</code>目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 赋执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /tmp/busybox-armv8l</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/mtdblock0 bs=1M | ./busybox-armv8l nc 192.168.10.100 5000</span><br></pre></td></tr></table></figure><p>在pc端下个netcat，具体参考：<a href="https://cloud.tencent.com/developer/article/2182697">https://cloud.tencent.com/developer/article/2182697</a></p><p>我使用MSYS2，更加简单方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br><span class="line">pacman -S openbsd-netcat pv</span><br><span class="line">nc -l -p 5000 | pv &gt; spi0_0.img</span><br></pre></td></tr></table></figure><p>至此固件备份结束。</p><h1>刷入 OpenWrt/ImmortalWrt</h1><h2 id="收集文件">收集文件</h2><p>首先前往官方 Firmware Selector （如果你有能力，可以直接前往国内镜像站下载相关文件）</p><p>需要获取的文件如下：</p><table><thead><tr><th>文件短名</th><th style="text-align:center">下载链接</th><th>备注</th></tr></thead><tbody><tr><td><code>preloader.bin</code></td><td style="text-align:center"><a href="https://mirrors.nju.edu.cn/immortalwrt/releases/23.05.4/targets/mediatek/filogic/immortalwrt-23.05.4-mediatek-filogic-nokia_ea0326gmp-preloader.bin">Go</a></td><td>路由器的第一级Bootloader，由MTK提供的SDK提供。一般的厂商没有对其做出修改的能力，不刷也行。</td></tr><tr><td><code>bl31-uboot.fip</code></td><td style="text-align:center"><a href="https://mirrors.nju.edu.cn/immortalwrt/releases/23.05.4/targets/mediatek/filogic/immortalwrt-23.05.4-mediatek-filogic-nokia_ea0326gmp-bl31-uboot.fip">Go</a></td><td>引导程序映像。 用于启动时加载操作系统的底层软件。</td></tr><tr><td><code>initramfs-recovery.itb</code></td><td style="text-align:center"><a href="https://mirrors.nju.edu.cn/immortalwrt/releases/23.05.4/targets/mediatek/filogic/immortalwrt-23.05.4-mediatek-filogic-nokia_ea0326gmp-initramfs-recovery.itb">Go</a></td><td>集成最小文件系统的 Linux 内核。适用于首次安装或故障恢复。</td></tr><tr><td><code>squashfs-sysupgrade.itb</code></td><td style="text-align:center"><a href="https://mirrors.nju.edu.cn/immortalwrt/releases/23.05.4/targets/mediatek/filogic/immortalwrt-23.05.4-mediatek-filogic-nokia_ea0326gmp-squashfs-sysupgrade.itb">Go</a></td><td>完整的系统，用于刷写新系统或更新现有系统。</td></tr></tbody></table><p>此外，我们还需要一个TFTP服务器，建议使用 Tftpd64 ： <a href="https://bitbucket.org/phjounin/tftpd64/downloads/tftpd64.464.zip">https://bitbucket.org/phjounin/tftpd64/downloads/tftpd64.464.zip</a></p><h2 id="刷写-U-Boot">刷写 U-Boot</h2><p>下载 bl31-uboot.fip，并在stock固件环境执行以下命令刷入FIP分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd write immortalwrt-23.05.4-mediatek-filogic-nokia_ea0326gmp-bl31-uboot.fip FIP    </span><br></pre></td></tr></table></figure><h2 id="进入-Initramfs-恢复环境">进入 Initramfs 恢复环境</h2><p>将PC的IP设置为 <code>192.168.1.254</code>，子网掩码<code>255.255.255.0</code>。</p><p>将下载好的<code>initramfs-recovery.itb</code>文件去除版本前缀，即去掉<code>23.05.4-</code>，重命名之后的文件名应该像这样：<code>immortalwrt-mediatek-filogic-nokia_ea0326gmp-initramfs-recovery.itb</code>。把该文件放置在 Tftpd64 的根目录，并启动 Tftpd 服务器。这一步最好关闭防火墙，不然很大可能失败。</p><p>拔路由器电源，找个针按住路由器上的 Reset ，插电开机。</p><p>过一会儿 tftp 服务器会读条，等待 Initramfs 恢复环境启动。等到路由器上的LAN灯亮起，就成功启动了，此时已经成功一半。</p><h2 id="重新分区并刷入系统">重新分区并刷入系统</h2><p>SSH 连接<code>192.168.1.1</code>进入 Initramfs 恢复环境。首先新建目录<code>mkdir -p /tmp/flash</code>，scp上传4个刷机所需文件。</p><h2 id="获取权限">获取权限</h2><p>安装<code>kmod-mtd-rw</code>，去你对应版本的包源里面找，比如 <a href="https://mirrors.nju.edu.cn/immortalwrt/releases/23.05.4/targets/mediatek/filogic/packages/">https://mirrors.nju.edu.cn/immortalwrt/releases/23.05.4/targets/mediatek/filogic/packages/</a> 。</p><p>SCP 传到<code>/tmp/flash</code>，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install --nodeps kmod-mtd-rw*.ipk</span><br></pre></td></tr></table></figure><p>安装，再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod /lib/modules/$(<span class="built_in">uname</span> -r)/mtd-rw.ko i_want_a_brick=1</span><br></pre></td></tr></table></figure><p>以安装内核模块，获取 mtd 的写权限。</p><p>执行以下命令确认分区表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ImmortalWrt:/tmp/flash# cat /proc/mtd</span><br><span class="line">dev:    size   erasesize  name</span><br><span class="line">mtd0: 00100000 00020000 &quot;bl2&quot;</span><br><span class="line">mtd1: 00080000 00020000 &quot;u-boot-env&quot;</span><br><span class="line">mtd2: 00200000 00020000 &quot;factory&quot;</span><br><span class="line">mtd3: 00200000 00020000 &quot;fip&quot;</span><br><span class="line">mtd4: 00200000 00020000 &quot;config&quot;</span><br><span class="line">mtd5: 00200000 00020000 &quot;config2&quot;</span><br><span class="line">mtd6: 07680000 00020000 &quot;ubi&quot;</span><br></pre></td></tr></table></figure><p>这里你的输出结果如果跟我的不一样，建议你不要进行下一步操作，以免破坏原厂分区。</p><h2 id="建立-U-Boot-环境变量分区">建立 U-Boot 环境变量分区</h2><p>执行以下命令重新建立 UBI 子卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubidetach -p /dev/mtd6 &amp;&amp; ubiformat /dev/mtd6 -y &amp;&amp; ubiattach -p /dev/mtd6</span><br><span class="line">ubimkvol /dev/ubi0 -n 0 -N ubootenv -s 128KiB</span><br><span class="line">ubimkvol /dev/ubi0 -n 1 -N ubootenv2 -s 128KiB</span><br></pre></td></tr></table></figure><h2 id="创建片上恢复分区">创建片上恢复分区</h2><p>这一步是可选的。如果您不想使用 ubootmod 提供的 NAND 恢复启动功能，可以跳过此步骤。</p><p>但是假如你的路由器出现问题，你就要参照“进入 Initramfs 恢复环境” 一节，使用 tftp 进入 Initramfs 恢复环境。如果你刷了，在启动时按住 Reset 直接就能进入 Initramfs 恢复环境而无需在PC上启动 tftp 服务器。代价是ImmortalWrt系统会损失约10MB的可用空间，这是一个 Trade-off。</p><p>执行以下命令以创建片上恢复分区。这里恢复分区的大小要跟<code>initramfs-recovery.itb</code>的大小对应。即<code>11520KiB</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubimkvol /dev/ubi0 -n 2 -N recovery -s 11520KiB</span><br><span class="line">ubiupdatevol /dev/ubi0_2 /tmp/flash/initramfs-recovery.itb</span><br></pre></td></tr></table></figure><h2 id="刷入主分区">刷入主分区</h2><p>保险起见再刷一遍preloader与ubootmod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mtd write preloader.bin bl2</span><br><span class="line">mtd write bl31-uboot.fip fip</span><br></pre></td></tr></table></figure><p>最后使用<code>sysupgrade</code>命令刷写主分区，该命令执行后会自动重启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysupgrade -n squashfs-sysupgrade.itb</span><br></pre></td></tr></table></figure><p>自动重启完成后，访问<code>192.168.1.1</code>，享受openwrt吧！</p><p>最后放一张配置完的图</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;贝尔 EA0326GMP 是一款中国移动定制的WiFi 6 路由器，采用喜闻乐见的 MT7981B 方案，具有 128MB NAND 与 256MB DDR，无线规格为 2x2 MIMO AX3000。由于其优良的硬件规格与低廉的价格，该路由器具备了一定的可玩性与折腾价值。&lt;/p&gt;
&lt;p&gt;本教程旨在提供一个刷写官方OpenWrt/ImmortalWrt与其ubootmod的方法，为喜欢使用OpenWrt/ImmortalWrt opkg 生态的用户提供参考。&lt;/p&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>一次关于neofetch fastfetch输出卡住的debug</title>
    <link href="https://blog.lotusmomo.cn/2024/10/05/fetch-hanging-debug/"/>
    <id>https://blog.lotusmomo.cn/2024/10/05/fetch-hanging-debug/</id>
    <published>2024-10-05T18:29:00.000Z</published>
    <updated>2024-10-05T18:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>TL,DR: XShell关闭连接-SSH-隧道中的转发X11连接选项</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TL,DR: XShell关闭连接-SSH-隧道中的转发X11连接选项&lt;/p&gt;
</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>无授权 ACM 文献获取方法</title>
    <link href="https://blog.lotusmomo.cn/2024/07/25/acm-artical-download/"/>
    <id>https://blog.lotusmomo.cn/2024/07/25/acm-artical-download/</id>
    <published>2024-07-25T21:40:59.000Z</published>
    <updated>2024-07-25T21:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>我所在的高校没有购买 ACM 文献库授权，导致看不了 KDD 等 ACM 会议的论文。本文提供了一种方法，能够方便的下载到 ACM 论文，IEEE 也是同理。</p><span id="more"></span><p>前往中国科技云<a href="https://www.cstcloud.cn/">https://www.cstcloud.cn/</a> 点击右上角登录</p><p><img src="cst-pre-registration.png" alt="cst-pre-registration"></p><p>进入通行证页面，点击立即注册</p><p><img src="cst-registration.png" alt="cst-registration"></p><p>可以使用教育邮箱注册，注册完成后自动登录。此时我们前往有版权的ACM论文下载页，如：<br><a href="https://dl.acm.org/doi/10.1145/3606274.3606279">https://dl.acm.org/doi/10.1145/3606274.3606279</a></p><p><img src="acm-selection.png" alt="acm-selection"></p><p>点击下载后开始认证，不要搜yangzhou university，因为扬大没买:sweat_smile:。此时我们只要搜cas，翻一下找到国科大。</p><p><img src="cst-acknowledgement.png" alt="cst-acknowledgement"></p><p>欸嘿，确认登录。</p><p><img src="acm-approved.png" alt="acm-approved"></p><p>就可以下载了:yum: 快说谢谢中科院</p><p>P.S. 中科院版权挺全的，当作日常主力账号使用也没问题。另外还有在线Latex等功能，比答辩overleaf快多了，还有不限时长的腾讯会议等等，更多功能看看中国科技云首页。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我所在的高校没有购买 ACM 文献库授权，导致看不了 KDD 等 ACM 会议的论文。本文提供了一种方法，能够方便的下载到 ACM 论文，IEEE 也是同理。&lt;/p&gt;</summary>
    
    
    
    <category term="科研" scheme="https://blog.lotusmomo.cn/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>如何优雅监控zfs运行状态</title>
    <link href="https://blog.lotusmomo.cn/2024/03/14/zfs-monitor/"/>
    <id>https://blog.lotusmomo.cn/2024/03/14/zfs-monitor/</id>
    <published>2024-03-14T15:21:00.000Z</published>
    <updated>2024-03-14T15:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>TLDR: 使用 Grafana + InfluxDB + Telegraf。这也是清华大学TUNA所使用的方案。</p><span id="more"></span><h1>事件起因</h1><p>清华大学TUNA镜像站想必大家已经十分熟悉。TUNA提供了一个状态页面，可以监控服务器的流量、磁盘空间等等。经过一番探究，发现数据表都是静态渲染的。</p><h1>安装InfluxDB</h1><h1>安装Telegraf</h1><h2 id="编译安装zpool-influxdb">编译安装zpool_influxdb</h2><p>zpool_influxdb是一个用于 ZFS 池统计的 influxdb 线路协议代理，适用于 telegraf。</p><h1>安装Grafana</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;TLDR: 使用 Grafana + InfluxDB + Telegraf。这也是清华大学TUNA所使用的方案。&lt;/p&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次存储服务器的搭建</title>
    <link href="https://blog.lotusmomo.cn/2023/04/24/nas-setting-up/"/>
    <id>https://blog.lotusmomo.cn/2023/04/24/nas-setting-up/</id>
    <published>2023-04-24T00:59:55.000Z</published>
    <updated>2023-04-24T00:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年由于科研的需要，有大量的数据存储需求。再加之对百度网盘存储不放心，准备自建存储服务器，这样可以摆脱所有云存储的需求，将数据牢牢掌握在自己手中。我准备配一台存储服务器，这种设备叫做<code>NAS (Net Attached Storage)</code>，即<strong>网络附加存储</strong>。可以通过<code>NFS</code>，<code>SMB/CIFS</code>，<code>FTP</code>，<code>iSCSI</code>等协议访问服务器内的文件。</p><span id="more"></span><h1>准备硬件</h1><h2 id="硬盘">硬盘</h2><p>2021年 Chia 狂潮已过，二手硬盘的价格降到了史低。在咸鱼上与奸商斗智斗勇，以920元/片的价格购得8片西部数据 WDC HC550 16T 硬盘。</p><p><img src="goofish-screenshot.png" alt="goofish-scrshot"></p><p>看盘片的信息，这批硬盘应该是华三的服务器下架硬盘。根据硬盘上的SN码（小标签），在华三官网上查询，居然都还在保，到2024年，算是捡了个漏。</p><p><img src="h3c-warranty-check.png" alt="h3c-warranty-check"></p><h2 id="服务器">服务器</h2><p>又在淘宝上购买了一台存储服务器，型号为华为RH2288V2。这台服务器具有12盘位，支持双路至强E5V2处理器，DDR3 REG ECC内存，LSI2308直通卡，具有很高的性价比。正好手头有很多DDR3 REG ECC的服务器内存，正好利用起来。服务器到手后内部很干净。</p><p><img src="server-internal.png" alt="server-internal"></p><h2 id="网卡">网卡</h2><p>万兆网卡自然也是不可或缺的，正好在咸鱼上看到一块不错的惠普万兆光口网卡价格不错，型号为 NC523SFP 是 Qlogic 的 OEM 产品。</p><p><img src="10g-nic.png" alt="10g-nic"></p><h2 id="固态硬盘">固态硬盘</h2><p>此外，还要准备一块系统盘，我购买了一块 NVMe 的固态盘，三星 PM981A 。此盘为三星970 Pro的 OEM 版本，性能尚可。再加上一块PCIe转NVMe的转接板，就可以使用了。</p><p>由于x79的BIOS无法识别NVMe的硬盘，所以虽然系统里能看到，但是却是无法从这块硬盘启动的。对于这种情况，一般有两种解决思路：</p><ul><li><p>从源头解决问题。在BIOS中添加NVMe的驱动<code>NVMeExpressDxE.ffs</code>。</p><p>使用这种方法可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/57240058">https://zhuanlan.zhihu.com/p/57240058</a></p></li><li><p>曲线救国。在一个U盘中写入Clover，用Clover链式引导NVMe中的操作系统。</p><p>使用这种方法可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/508424810">https://zhuanlan.zhihu.com/p/508424810</a></p></li></ul><h1>安装操作系统</h1><p>其实NAS系统有很多选择，比如群晖DSM，UNRAID，TrueNAS Core/Scale等等。但是我不喜欢这类成品NAS系统。我这次选择安装Debian 11，从头开始配置。这样我就能掌控系统的所有细节，也能在踩各种坑的过程中学习到一些东西。</p><ol><li><p>从 BFSU <s>广搜大学</s>(bushi 开源软件镜像站下载 Debian non-free 的 Live CD。选择non-free的原因是这种镜像中含有非自由固件，服务器上一些稀奇古怪的硬件可能并不提供开源自由的驱动，并没有被整合入Debian CD中。选择Live CD的原因在于可以在安装时临时进入系统环境，再次确保没有兼容性问题。</p><p><img src="live-cd.png" alt="live-cd"></p></li><li><p>使用Rufus或者其他镜像工具将下载的<code>iso</code>镜像写入U盘，或者直接使用Ventory。我更推荐后者。</p></li><li><p>从U盘启动，在启动界面选择<code>Graphic install</code>，按照安装程序的指引安装系统。</p><blockquote><p>Tips: 不知道是不是 Debian 安装程序的 bug ，在开始最好不要连接互联网。因为一旦连接了互联网，无论后面的步骤选择什么镜像源，哪怕是国内的镜像源，实际上都会连接到<code>ftp.debian.org</code>这个境外的官方源，速度极慢，即使你选择了不使用网络镜像。如果不联网，只会使用iso内部的源，安装很快就能完成。</p></blockquote></li></ol><h1>基础工作</h1><p>以下的工作默认为<code>root</code>用户环境下进行。务必谨慎操作，除非你知道你在做什么。</p><ul><li><p>换源</p><p>执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> &gt; /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/debian/ bullseye main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/debian/ bullseye-updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/debian/ bullseye-backports main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/debian/ bullseye-backports main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/debian-security bullseye-security main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb https://security.debian.org/debian-security bullseye-security main contrib non-free</span></span><br><span class="line"><span class="comment"># # deb-src https://security.debian.org/debian-security bullseye-security main contrib non-free</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这将把中间的内容写入<code>/etc/apt/sources.list</code>文件中，直到终端读取到<code>EOF</code>字符串。</p><p>再运行<code>apt update</code>来将软件源写入缓存。</p></li><li><p>安装常用工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y -f openssh-server vim git zsh wget curl build-essential neofetch tmux htop apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure></li><li><p>一些配置</p><ul><li><p><code>ssh</code>允许<code>root</code>用户登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PermitRootLogin yes&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li><li><p>配置<code>oh-my-zsh</code>与<code>powerline-10k</code></p><blockquote><p>Tips: <code>zsh</code>配合<code>oh-my-zsh</code>与<code>powerline-10k</code>可以大大提高终端工作的效率。优秀的终端补全功能会让你用一次就离不开它。当然选择开箱即用的<code>fish</code>也未尝不可，只需<code>apt-get install -y fish</code>并且<code>chsh -s /usr/bin/fish</code>。</p></blockquote><p>在任意 shell 下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirrors/oh-my-zsh.git</span><br><span class="line"><span class="built_in">cd</span> oh-my-zsh/tools</span><br><span class="line">REMOTE=https://gitee.com/mirrors/oh-my-zsh.git sh install.sh <span class="comment">#To change remote</span></span><br></pre></td></tr></table></figure><p>进入<code>zsh</code>环境后，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf oh-my-zsh</span><br><span class="line">git -C <span class="variable">$ZSH</span> remote set-url origin https://gitee.com/mirrors/oh-my-zsh.git</span><br><span class="line">git -C <span class="variable">$ZSH</span> pull</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br><span class="line">omz theme <span class="built_in">set</span> powerlevel10k/powerlevel10k</span><br></pre></td></tr></table></figure><p>然后<code>p10k</code>会自动进入主题的配置，选择你喜欢的终端主题吧！</p></li><li><p>安装<code>conda</code></p><blockquote><p>Tips: 对于任意<code>Linux</code>发行版，我都不推荐直接使用系统的<code>Python</code>。因为有很多软件包依赖于系统提供的<code>Python</code>，而<code>Python</code>有一套自己的包管理体系<code>pip</code>，很容易一不小心把系统搞炸。因此我选择使用另外一套<code>Python</code>环境，依据你的喜好可以选择<code>Anaconda</code>，<code>Miniconda</code>或者<code>conda-forge</code>均可。此处以<code>Anaconda</code>为例。</p></blockquote><p>执行以下命令安装<code>Anaconda3</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://mirrors.nju.edu.cn/anaconda/archive/Anaconda3-2022.10-Linux-x86_64.sh</span><br><span class="line"><span class="built_in">chmod</span> +x ./Anaconda3-2022.10-Linux-x86_64.sh</span><br><span class="line">.Anaconda3-2022.10-Linux-x86_64.sh</span><br><span class="line">conda init zsh</span><br><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>文件系统的选择</h1><p>对于安装NAS而言，最重要的莫过于选择文件系统了。由于系统基于<code>Linux</code>，还是有不少文件系统可以选择的。</p><h2 id="EXT4">EXT4</h2><p><code>EXT4</code>全称为<code>Fourth extended filesystem</code>，第四代可扩展文件系统，可以说是<code>Linux</code>上最流行的文件系统了。但是这个系统用作存储数据，还是有些简陋，缺乏可靠性。在此不过多介绍。详细的资料可参考：</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/Ext4">Ext4 - 维基百科，自由的百科全书</a></li><li><a href="https://wiki.archlinuxcn.org/wiki/Ext4">Ext4 - ArchWiki</a></li></ul><h2 id="Btrfs">Btrfs</h2><p><code>Btrfs</code>即<code>B-Tree Filesystem</code>，是一种支持<code>CoW</code>（写时拷贝）的文件系统。Btrfs也宣称专注在“容错、修复及易于管理”。这种文件系统在<code>Arch Linux</code>上较为流行。详细的资料可参考：</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/Btrfs">Btrfs - 维基百科，自由的百科全书</a></li><li><a href="https://wiki.archlinuxcn.org/wiki/Btrfs">Btrfs - ArchWiki</a></li></ul><h2 id="ZFS">ZFS</h2><p>下面我将着重介绍<code>ZFS</code>。一方面原因，<code>ZFS</code>是我认为最好的文件系统。另外一方面，<code>ZFS</code>有关的资料在国内十分稀少。</p><p><img src="openzfs.svg" alt="OpenZFS"></p><p><code>ZFS</code>的全称为<code>Zettabyte Filesystem</code>，最早是 Sun 开发应用于 Solaris 的操作系统，<code>ZFS</code>随着<code>OpenSolaris</code>一起开源了。在2010年，Sun被Oracle收购，<code>ZFS</code>成为Oracle的注册商标。Oracle停止为 <code>OpenSolaris</code> 和 <code>ZFS</code> 项目提供更新的源代码，使得 Oracle 的 <code>ZFS</code> 转为闭源。因此，有人成立了<code>illumos</code>项目，去维护已经存在的开源的<code>Solaris</code>代码，并且在2013年成立<code>OpenZFS</code>以配合<code>ZFS</code>的开源发展。<code>OpenZFS</code>维护管理核心ZFS代码。但是<code>ZFS</code>的代码采用<code>CDDL</code> （通用开发与散布许可证），与<code>Linux</code>内核的<code>GPL-v2</code>许可证相冲突，无法与<code>Linux</code>同时分发。但是藉由<code>DKMS</code> （动态内核模块支持）,我们可以添加内核模块，使内核支持<code>ZFS</code>的读写。</p><h2 id="安装">安装</h2><p>执行以下命令以安装<code>ZFS</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y zfsutils-linux</span><br></pre></td></tr></table></figure><h2 id="使用">使用</h2><h3 id="创建存储池">创建存储池</h3><blockquote><p>Tips: 这里我使用raidz2，这是一种“软raid”。类似于RAID6，raidz2最多允许两块物理磁盘同时损坏而不会丢失数据。请不要心疼存储空间，因为你的数据的价值可能数倍于存储介质。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zpool create mainPool raidz2 sda sdb sdc sdd sde sdf sdg sdh -f</span><br></pre></td></tr></table></figure><p>创建的存储池将默认挂载于<code>/mainPool</code>。此时已经可以向其中写入文件，但是不建议这样做。</p><h3 id="创建文件系统">创建文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zfs create mainPool/data</span><br><span class="line">zfs create mainPool/pub</span><br></pre></td></tr></table></figure><h3 id="验证">验证</h3><p>运行<code>df -h</code>可以看出文件系统已经被挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">文件系统          容量  已用  可用 已用% 挂载点</span><br><span class="line">udev               24G     0   24G    0% /dev</span><br><span class="line">tmpfs             4.8G  3.4M  4.8G    1% /run</span><br><span class="line">/dev/nvme0n1p2    233G   11G  210G    5% /</span><br><span class="line">tmpfs              24G     0   24G    0% /dev/shm</span><br><span class="line">tmpfs             5.0M     0  5.0M    0% /run/lock</span><br><span class="line">/dev/nvme0n1p1    511M  5.8M  506M    2% /boot/efi</span><br><span class="line">tmpfs             4.8G   72K  4.8G    1% /run/user/0</span><br><span class="line">mainPool           76T  384K   76T    1% /mainPool</span><br><span class="line">mainPool/mirrors   76T   16G   76T    1% /mainPool/mirrors</span><br><span class="line">mainPool/pub       77T  324G   76T    1% /mainPool/pub</span><br><span class="line">mainPool/data      80T  4.0T   76T    6% /mainPool/data</span><br><span class="line">mainPool/pve       76T   15G   76T    1% /mainPool/pve</span><br><span class="line">/dev/sdj1          15T  2.1T   13T   14% /chenweitong</span><br><span class="line">tinyPool          1.8T  128K  1.8T    1% /tinyPool</span><br><span class="line">tinyPool/fs       1.8T  128K  1.8T    1% /tinyPool/fs</span><br><span class="line">tinyPool/data     1.8T   12G  1.8T    1% /tinyPool/data</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 具体的使用方法可参考<a href="https://docs.oracle.com/cd/E38902_01/html/E38893/index.html">Oracle的官方文档</a>，里面写的十分详细。有便于携带的PDF版本：<a href="https://docs.oracle.com/cd/E38902_01/pdf/E38893.pdf%E3%80%82">https://docs.oracle.com/cd/E38902_01/pdf/E38893.pdf。</a></p></blockquote><h1>共享配置</h1><h2 id="NFS">NFS</h2><p><code>nfs</code>是<code>Linux/UNIX</code>之间共享文件的常用方式。</p><h2 id="安装-2">安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>编辑<code>/etc/exports</code>并加入以下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/mainPool/pub     10.10.2.0/24(rw,all_squash,<span class="built_in">sync</span>)</span><br><span class="line">/mainPool/data    10.10.2.0/24(rw,root_squash,<span class="built_in">sync</span>)</span><br></pre></td></tr></table></figure><p>详细配置参数可以参考鸟哥的文章：<a href="http://cn.linux.vbird.org/linux_server/0330nfs.php">http://cn.linux.vbird.org/linux_server/0330nfs.php</a></p><p>每次更改配置后，都需要重载配置：<code>systemctl reload nfs-server.service</code>。</p><h2 id="挂载">挂载</h2><p>在另外一台机器上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 10.10.2.10:/mainPool/pub /mnt/pub</span><br></pre></td></tr></table></figure><p>再运行<code>df -h</code>就可以看到共享了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">文件系统                      容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                          7.8G     0  7.8G    0% /dev</span><br><span class="line">tmpfs                         1.6G  1.6M  1.6G    1% /run</span><br><span class="line">/dev/sda2                      88G   49G   35G   59% /</span><br><span class="line">tmpfs                         7.9G     0  7.9G    0% /dev/shm</span><br><span class="line">tmpfs                         5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs                         7.9G     0  7.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                     511M  5.3M  506M    2% /boot/efi</span><br><span class="line">tmpfs                         1.6G   44K  1.6G    1% /run/user/1000</span><br><span class="line">10.10.2.10:/mainPool/pub       77T  324G   76T    1% /mnt/pub</span><br></pre></td></tr></table></figure><h2 id="SMB-CIFS">SMB/CIFS</h2><p>如果想要让Windows也连接共享，smb无疑是最简便的方式。<code>Linux</code>上<code>smb</code>服务器的实现是<code>samba</code>。</p><h2 id="安装-3">安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install samba</span><br></pre></td></tr></table></figure><h2 id="配置-2">配置</h2><p><code>samba</code>的用户认证依赖于<code>UNIX</code>用户，所以首先要向系统添加用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd smbuser</span><br></pre></td></tr></table></figure><p>然后设置SMB的密码：</p><blockquote><p>Tips: 首次添加新用户要加上<code>-a</code>参数。</p></blockquote><p><code>smbpasswd smbuser -a</code></p><p>输入两次你想设置的密码就好了。</p><p>下一步，更改<code>samba</code>的配置文件，路径在<code>/etc/samba/smb.conf</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line">   aio read <span class="attr">size</span> = <span class="number">0</span></span><br><span class="line">   aio write <span class="attr">size</span> = <span class="number">0</span></span><br><span class="line">   min <span class="attr">protocol</span> = SMB2</span><br><span class="line">   <span class="attr">workgroup</span> = WORKGROUP</span><br><span class="line">   log <span class="attr">file</span> = /var/log/samba/log.%m</span><br><span class="line">   max log <span class="attr">size</span> = <span class="number">1000</span></span><br><span class="line">   <span class="attr">logging</span> = file</span><br><span class="line">   panic <span class="attr">action</span> = /usr/share/samba/panic-action %d</span><br><span class="line">   server <span class="attr">role</span> = standalone server</span><br><span class="line">   obey pam <span class="attr">restrictions</span> = <span class="literal">yes</span></span><br><span class="line">   unix password <span class="attr">sync</span> = <span class="literal">yes</span></span><br><span class="line">   passwd <span class="attr">program</span> = /usr/bin/passwd %u</span><br><span class="line">   passwd <span class="attr">chat</span> = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .</span><br><span class="line">   pam password <span class="attr">change</span> = <span class="literal">yes</span></span><br><span class="line">   map to <span class="attr">guest</span> = bad user</span><br><span class="line">   <span class="attr">security</span> = user</span><br><span class="line">   usershare allow <span class="attr">guests</span> = <span class="literal">yes</span></span><br><span class="line"><span class="section">[data]</span></span><br><span class="line">   <span class="attr">comment</span> = Private Files</span><br><span class="line">   <span class="attr">browseable</span> = <span class="literal">yes</span></span><br><span class="line">   <span class="attr">path</span> = /mainPool/data</span><br><span class="line">   create <span class="attr">mask</span> = <span class="number">0666</span></span><br><span class="line">   directory <span class="attr">mask</span> = <span class="number">0777</span></span><br><span class="line">   <span class="attr">public</span> = <span class="literal">no</span></span><br><span class="line">   <span class="attr">available</span> = <span class="literal">yes</span></span><br><span class="line">   <span class="attr">writable</span> = <span class="literal">yes</span></span><br><span class="line"><span class="section">[pub]</span></span><br><span class="line">   <span class="attr">comment</span> = Public Files</span><br><span class="line">   <span class="attr">browseable</span> = <span class="literal">yes</span></span><br><span class="line">   <span class="attr">path</span> = /mainPool/pub</span><br><span class="line">   create <span class="attr">mask</span> = <span class="number">0666</span></span><br><span class="line">   directory <span class="attr">mask</span> = <span class="number">0777</span></span><br><span class="line">   <span class="attr">public</span> = <span class="literal">yes</span></span><br><span class="line">   <span class="attr">available</span> = <span class="literal">yes</span></span><br><span class="line">   <span class="attr">writable</span> = <span class="literal">yes</span></span><br><span class="line">   guest <span class="attr">ok</span> = <span class="literal">yes</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips: 其中<code>   aio read size = 0</code>与<code>aio write size = 0</code>十分重要，用于关闭文件异步读写，这样可以大幅提升Windows读写共享文件夹的速度。</p></blockquote><p>这就是Windows下挂载共享的效果啦：</p><p><img src="mount-smb-win.png" alt="mount-smb-win"></p><h2 id="FTP">FTP</h2><p>另一种跨平台的文件共享方式就是<code>ftp</code>了。<code>Linux</code>上一个比较流行的<code>ftp</code>服务器实现为<code>vsftpd</code>。网上的教程很多，在这里就不赘述啦。可以参考：<a href="https://help.ubuntu.com/community/vsftpd">vsftpd - Community Help Wiki - Ubuntu Documentation</a>。</p><h1>总结</h1><p>上面的文章，介绍了我从购买硬件到配置共享的全过程，希望能对你有所帮助。其中内容难以面面俱到，可能也有所阙漏，希望各位读者发现后予以斧正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年由于科研的需要，有大量的数据存储需求。再加之对百度网盘存储不放心，准备自建存储服务器，这样可以摆脱所有云存储的需求，将数据牢牢掌握在自己手中。我准备配一台存储服务器，这种设备叫做&lt;code&gt;NAS (Net Attached Storage)&lt;/code&gt;，即&lt;strong&gt;网络附加存储&lt;/strong&gt;。可以通过&lt;code&gt;NFS&lt;/code&gt;，&lt;code&gt;SMB/CIFS&lt;/code&gt;，&lt;code&gt;FTP&lt;/code&gt;，&lt;code&gt;iSCSI&lt;/code&gt;等协议访问服务器内的文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.lotusmomo.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Home Assistant 搭建指南</title>
    <link href="https://blog.lotusmomo.cn/2023/04/13/hass-deploy/"/>
    <id>https://blog.lotusmomo.cn/2023/04/13/hass-deploy/</id>
    <published>2023-04-13T09:38:40.000Z</published>
    <updated>2023-04-13T09:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Home Assistant（以下简称HASS）是一款智能家居自动化平台，旨在帮助用户将各种智能设备整合在一起，从而实现更便捷、更高效、更智能的生活方式。通过HASS，用户可以轻松地控制家中的照明、温度、安防、音频、视频等各类设备，实现更智能、更个性化的家庭体验。HASS支持众多的智能设备品牌和协议，用户可以根据自己的需求进行定制和配置，实现智能家居的全面升级。</p><span id="more"></span><h2 id="准备环境">准备环境</h2><p>HASS是基于Docker开发的，已经为云原生的生产环境做好了准备。上至运行在服务器上的k8s集群，下至小巧的嵌入式设备，都能运行HASS。下面给出<code>Docker</code>与<code>k8s-pods</code>的安装方法。</p><h3 id="Docker-compose">Docker-compose</h3><ul><li>执行<code>mkdir home-assistant &amp;&amp; cd home-assistant</code>创建文件夹，并且新建文件<code>docker-compose.yaml</code>，写入如下的配置文件：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">homeassistant:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">homeassistant</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">homeassistant/home-assistant</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips: 网络模式<code>host</code>仅能在<code>Linux</code>下使用。HomeKit扩展依赖<code>mDNS</code>功能，仅在<code>host</code>模式下可用。</p></blockquote></li><li>运行<code>docker-compose up -d</code>启动。</li></ul><h3 id="K8s-deployment-yaml">K8s deployment yaml</h3><ul><li>将以下内容写入<code>hass.yaml</code>:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">finalizers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kubernetes.io/pvc-protection</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">homeassistant</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">外挂存储的名字</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">homeassistant</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">homeassistant</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">homeassistant</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">homeassistant</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">homeassistant/home-assistant</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8123</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">64Mi</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/config</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">homeassistant</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">homeassistant</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">homeassistant</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8123</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8123</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">homeassistant</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure></li><li><code>kubectl apply -f homeassistant.yaml</code><br>最后，访问<code>http://server_ip:8123</code>来进行初始化，设置用户名、密码等。</li></ul><h2 id="安装插件">安装插件</h2><p>HASS的高扩展性主要来源于它丰富的插件与扩展。本章节将以米家与HomeKit为例，讲述插件的安装与配置过程。</p><h3 id="安装Home-Assistant-Community-Store-HACS">安装Home Assistant Community Store (HACS)</h3><ul><li>进入容器内部，并cd进入到HASS配置目录：<br><code>docker exec -it homeassistant bash</code></li><li>使用命令行安装：<br><code>wget -O - https://hacs.vip/get | bash -</code><br>如果上面的命令执行后卡住不动，或没有提示安装成功，请尝试下面的命令：<br><code>wget -O - https://hacs.vip/get | HUB_DOMAIN=ghproxy.com/github.com bash -</code></li></ul><h3 id="安装hass-xiaomi-miot米家插件">安装hass-xiaomi-miot米家插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it homeassistant bash</span><br><span class="line">wget -q -O - https://cdn.jsdelivr.net/gh/al-one/hass-xiaomi-miot/install.sh | HUB_DOMAIN=hub.fastgit.org bash -</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker-compose restart</span><br></pre></td></tr></table></figure><h4 id="配置">配置</h4><ul><li>配置 - 集成 - 管理集成 - 添加集成；</li><li>搜索<code>xiaomi</code>，选择 <code>xiaomi-miot-auto</code>；</li><li>选择“账号集成模式”；</li><li>输入小米账号（手机号）密码，选择”云端模式“；<br>此时，所有米家物联网设备已经接入完毕。</li></ul><h3 id="安装-Apple-HomeKit-插件">安装 Apple HomeKit 插件</h3><ul><li>前往配置 - 集成 - 管理集成 - 添加集成 - Homekit；</li><li>使用iOS设备上的家庭APP扫描网页“通知”面板上的二维码来添加HASS网关；</li><li>跟着苹果提示，把设备都添加到“家庭”中。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Home Assistant（以下简称HASS）是一款智能家居自动化平台，旨在帮助用户将各种智能设备整合在一起，从而实现更便捷、更高效、更智能的生活方式。通过HASS，用户可以轻松地控制家中的照明、温度、安防、音频、视频等各类设备，实现更智能、更个性化的家庭体验。HASS支持众多的智能设备品牌和协议，用户可以根据自己的需求进行定制和配置，实现智能家居的全面升级。&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://blog.lotusmomo.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>在Rock5B开发板上安装RealVNC服务器</title>
    <link href="https://blog.lotusmomo.cn/2023/03/22/rock5b-realvnc/"/>
    <id>https://blog.lotusmomo.cn/2023/03/22/rock5b-realvnc/</id>
    <published>2023-03-22T05:21:36.000Z</published>
    <updated>2023-03-22T05:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1>获取安装包</h1><p>因为RealVNC的arm版本专为树莓派提供，我们需要访问<a href="https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/%E6%9D%A5%E6%89%BE%E5%88%B0%E5%AE%89%E8%A3%85%E5%8C%85%E3%80%82%E4%B8%8B%E8%BD%BD6.x%E7%9A%84%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%9A%5Brealvnc-vnc-server_6.9.1.46706_armhf.deb%5D(https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/realvnc-vnc-server_6.9.1.46706_armhf.deb)%E3%80%82%E5%9B%A0%E4%B8%BA%E6%9C%80%E6%96%B0%E7%9A%847.x%E4%BB%8ELicene">https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/来找到安装包。下载6.x的最新版本：[realvnc-vnc-server_6.9.1.46706_armhf.deb](https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/realvnc-vnc-server_6.9.1.46706_armhf.deb)。因为最新的7.x从Licene</a> Key验证改为License File，即使安装了也无法激活。</p><span id="more"></span><h1>安装软件包</h1><p>执行<code>sudo -i</code>切换到root用户，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/realvnc-vnc-server_6.9.1.46706_armhf.deb</span><br><span class="line">dpkg -i realvnc-vnc-server_6.9.1.46706_armhf.deb</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -f</span><br></pre></td></tr></table></figure><h1>链接库文件</h1><p>此时如果直接打开vncserver，会报错：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncserver: <span class="keyword">error</span> <span class="keyword">while</span> loading shared libraries: libbcm_host.<span class="keyword">so</span>.0: cannot <span class="keyword">open</span> shared object <span class="keyword">file</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure><p>这是因为没有链接动态库。我们需要手动链接一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/aarch64-linux-gnu/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> libvcos.so /usr/lib/libvcos.so.0</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> libvchiq_arm.so /usr/lib/libvchiq_arm.so.0</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> libbcm_host.so /usr/lib/libbcm_host.so.0</span><br></pre></td></tr></table></figure><h1>关闭Wayland</h1><p>大部分vnc服务器无法在Wayland桌面环境下运行。<code>sudo vim /etc/gdm3/custom.conf</code>并取消注释这一行：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#WaylandEnable=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h1>启动服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> vncserver-virtuald.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> vncserver-x11-serviced.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl start vncserver-virtuald.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl start vncserver-x11-serviced.service</span><br></pre></td></tr></table></figure><p>重启开发板。</p><h1>激活</h1><p>realvnc的激活码在网上很容易找到，如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">VKUPN</span>-MTHHC-UDHGS-UWD76-<span class="number">6</span>N36A    有效期至<span class="number">2029</span>-<span class="number">07</span>-<span class="number">21</span></span><br><span class="line"><span class="attribute">77NVU</span>-D9G5T-<span class="number">79</span>ESS-V9Y6X-JMVGA    有效期至<span class="number">2024</span>-<span class="number">12</span>-<span class="number">02</span></span><br></pre></td></tr></table></figure><p>使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnclicense -add VKUPN-MTHHC-UDHGS-UWD76-6N36A</span><br></pre></td></tr></table></figure><p>来应用激活码。</p><p><img src="/legacy/imgs/081932238c611ee75684ef379a1e5f85.png" alt="connect-via-realvnc"></p><p>此时可以看到，已经可以通过vnc完美连接了。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;获取安装包&lt;/h1&gt;
&lt;p&gt;因为RealVNC的arm版本专为树莓派提供，我们需要访问&lt;a href=&quot;https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/%E6%9D%A5%E6%89%BE%E5%88%B0%E5%AE%89%E8%A3%85%E5%8C%85%E3%80%82%E4%B8%8B%E8%BD%BD6.x%E7%9A%84%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%9A%5Brealvnc-vnc-server_6.9.1.46706_armhf.deb%5D(https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/realvnc-vnc-server_6.9.1.46706_armhf.deb)%E3%80%82%E5%9B%A0%E4%B8%BA%E6%9C%80%E6%96%B0%E7%9A%847.x%E4%BB%8ELicene&quot;&gt;https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/来找到安装包。下载6.x的最新版本：[realvnc-vnc-server_6.9.1.46706_armhf.deb](https://mirrors.bfsu.edu.cn/raspberrypi/pool/main/r/realvnc-vnc/realvnc-vnc-server_6.9.1.46706_armhf.deb)。因为最新的7.x从Licene&lt;/a&gt; Key验证改为License File，即使安装了也无法激活。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.lotusmomo.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>新GPU服务器联网指南</title>
    <link href="https://blog.lotusmomo.cn/2023/03/02/gpu-server-internet-next/"/>
    <id>https://blog.lotusmomo.cn/2023/03/02/gpu-server-internet-next/</id>
    <published>2023-03-02T04:49:00.000Z</published>
    <updated>2023-11-21T02:46:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>新服务器运行在<code>Docker</code>容器里，使用信息中心分配的静态ip连接，无法连接至外部互联网。解决方法如下：</p><span id="more"></span><h2 id="Linux">Linux</h2><h3 id="Debian-Ubuntu">Debian/Ubuntu</h3><ol><li>安装Squid<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install squid</span><br></pre></td></tr></table></figure></li><li>开启<code>IPv4</code>转发<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure></li><li>修改配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/squid/squid.conf</span><br></pre></td></tr></table></figure>删除<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http_access</span> <span class="literal">deny</span> <span class="literal">all</span></span><br></pre></td></tr></table></figure>添加一行<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http_access</span> <span class="literal">allow</span> <span class="literal">all</span></span><br></pre></td></tr></table></figure></li><li>启动Squid<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now squid</span><br></pre></td></tr></table></figure></li></ol><h3 id="CentOS-RHEL">CentOS/RHEL</h3><ol><li>安装Squid<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install squid</span><br></pre></td></tr></table></figure></li><li>确认版本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep squid</span><br></pre></td></tr></table></figure></li><li>开启<code>IPv4</code>转发<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure></li><li>修改配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/squid/squid.conf</span><br></pre></td></tr></table></figure>删除<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http_access</span> <span class="literal">deny</span> <span class="literal">all</span></span><br></pre></td></tr></table></figure>添加一行<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http_access</span> <span class="literal">allow</span> <span class="literal">all</span></span><br></pre></td></tr></table></figure></li><li>启动Squid<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now squid</span><br></pre></td></tr></table></figure></li></ol><p>会用Linux的应该不要我教你怎么转发ssh吧:joy:</p><h2 id="Windows">Windows</h2><ol><li>下载并安装<code>Squid for windows</code>：<a href="https://squid.diladele.com/">https://squid.diladele.com/</a></li><li>选择<code>Console App</code>下载一个msi并安装：<a href="https://packages.diladele.com/squid/4.14/squid.msi">https://packages.diladele.com/squid/4.14/squid.msi</a></li><li>右键状态栏图标，点击打开配置：<br><img src="/legacy/imgs/63f219332288e2377b5f689f511526db.png" alt="image-20230302113031594"></li><li>删除<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http_access</span> <span class="literal">deny</span> <span class="literal">all</span></span><br></pre></td></tr></table></figure>添加一行   <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http_access</span> <span class="literal">allow</span> <span class="literal">all</span></span><br></pre></td></tr></table></figure></li><li>重启Squid</li><li>在XShell里设置端口转发<img src="/legacy/imgs/6cc6cbaff27952d31e19a6efa0b8d0ac.png" alt="image-20230302113228335"></li><li>连接到服务器，在<code>~/.bashrc</code>或<code>~/.zshrc</code>中添加以下配置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proxy configure</span></span><br><span class="line"><span class="function"><span class="title">setproxy</span></span>() &#123;</span><br><span class="line">    <span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;http://127.0.0.1:3128&quot;</span></span><br><span class="line">    <span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;http://127.0.0.1:3128&quot;</span></span><br><span class="line">    <span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;http://127.0.0.1:3128&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">unsetproxy</span></span>() &#123;</span><br><span class="line">    <span class="built_in">unset</span> HTTP_PROXY</span><br><span class="line">    <span class="built_in">unset</span> HTTPS_PROXY</span><br><span class="line">    <span class="built_in">unset</span> ALL_PROXY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>新建文件<code>/etc/apt/apt.conf.d/proxy.conf</code>，并写入以下内容：<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Acquire</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">HTTP</span>:<span class="string">:proxy &quot;http://127.0.0.1:3128/&quot;;</span></span><br><span class="line">  <span class="attr">HTTPS</span>:<span class="string">:proxy &quot;http://127.0.0.1:3128/&quot;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li>换源（此处以北京外国语大学镜像为例）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.0</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">touch</span> /etc/apt/sources.list</span><br><span class="line"><span class="built_in">sudo</span> vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>写入以下内容：<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deb</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"><span class="attr">deb-src</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deb</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="attr">deb-src</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deb</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"><span class="attr">deb-src</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deb</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="attr">deb-src</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## Not recommended</span></span><br><span class="line"><span class="comment"># deb http://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></li><li>运行<code>sudo apt-get update</code>，发现已经可以更新。</li><li>运行   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setproxy</span><br><span class="line">curl baidu.com -x <span class="variable">$&#123;HTTP_PROXY&#125;</span></span><br></pre></td></tr></table></figure>出现以下内容   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=http://www.baidu.com/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>即大功告成。</li><li>强烈建议安装<code>Anaconda3</code>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://mirrors.nju.edu.cn/anaconda/archive/Anaconda3-2022.10-Linux-x86_64.sh</span><br><span class="line"><span class="built_in">chmod</span> +x Anaconda3-2022.10-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-2022.10-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></li><li><code>Pypi</code>换源：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -i https://mirrors.bfsu.edu.cn/pypi/web/simple --upgrade pip</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.bfsu.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure></li><li><code>Conda</code>换源：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.condarc</span><br><span class="line">vim ~/.condarc</span><br></pre></td></tr></table></figure>输入以下内容：   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch-lts:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">https://mirrors.bfsu.edu.cn/anaconda/cloud</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;新服务器运行在&lt;code&gt;Docker&lt;/code&gt;容器里，使用信息中心分配的静态ip连接，无法连接至外部互联网。解决方法如下：&lt;/p&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>自适应遥感水印</title>
    <link href="https://blog.lotusmomo.cn/2022/09/23/adaptive-remote-sensing-watermarking/"/>
    <id>https://blog.lotusmomo.cn/2022/09/23/adaptive-remote-sensing-watermarking/</id>
    <published>2022-09-23T10:02:00.000Z</published>
    <updated>2022-11-05T04:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>问题可以分成两部分解决：<strong>自适应</strong>与<strong>水印</strong>。</p><span id="more"></span><h2 id="自适应-Adaptive">自适应 (Adaptive)</h2><p>由于处理的目标数据为遥感图像。典型的遥感图像如下：<br><img src="/legacy/imgs/15d22b9217501fee6ad3531e235abb82.png" alt="图片来自LEVIR-CD"></p><h3 id="共同要求">共同要求</h3><ul><li><h4 id="针对遥感图像自适应（主要创新点）">针对遥感图像自适应（主要创新点）</h4><blockquote><p>要结合遥感图像的特征，如果简单的将遥感图当作普通图像来处理，那就没意思。</p><p>分为显式特征与隐式特征：</p><ul><li>显式：地物类型，地物特征；</li><li>隐式：在神经网络中引入上下文注意（Context Attention）。</li></ul></blockquote></li><li><h4 id="水印要具有鲁棒性（Robustness）">水印要具有鲁棒性（Robustness）</h4><blockquote><p>能抗多种攻击。</p></blockquote></li><li><h4 id="水印要有不可感知性">水印要有不可感知性</h4><blockquote><p>评价指标：峰值信噪比（PSNR）。</p></blockquote></li></ul><h3 id="方案1">方案1</h3><h4 id="主要内容">主要内容</h4><p>修改地物的pattern，将水印携带的信息隐藏在生成的pattern中，或者pattern就是水印本身，且要求与原有的背景看起来不突兀。</p><blockquote><p><a href="https://arxiv.org/abs/2008.01919">Jia, X., Wei, X., Cao, X., and Han, X., “Adv-watermark: A Novel Watermark Perturbation for Adversarial Examples”, <i>arXiv e-prints</i>, 2020.</a><br>对图像做一次<strong>语义分割（Semantic segmentation）<strong>或者</strong>实例分割（Instance segmentation）</strong>，用*某种算法（？）*挑选出最适合进行显式修改（explicit modification）的pattern，然后使用<code>Generative Networks</code>生成对应的pattern，但是这个pattern里面嵌了水印。这样做的好处就是肉眼几乎无法分辨，因为是<code>GAN</code>生成的pattern。一开始，我尝试了<code>DCGAN</code>，主要考虑到<code>DCGAN</code>所生成的模型是可线性叠加的，只要用不同类别的地物训练出不同的模型，再分别赋以不同的权重，即可生成具有不同风格的伪遥感图像；具体的权重应该可以通过对标的地块进行简单的地物分类得出，这类算法已相对成熟。这是我所设想出的一种自适应的方法。</p></blockquote><h4 id="研究阻碍">研究阻碍</h4><p>对遥感数据的GAN极其难做，我首先尝试生成低分辨率的遥感图形。</p><blockquote><p><a href="https://arxiv.org/abs/1511.06434">Radford, A., Metz, L., and Chintala, S., “Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks”, <i>arXiv e-prints</i>, 2015.</a><br><code>DCGAN</code>原论文使用的数据集是<code>ImageNet</code>，里面什么数据都有。我尝试将数据集替换为<code>AID</code>数据集中的操场进行训练，但是效果十分不理想。模型最后是收敛的，但是生成的都是噪声，说明模型实际上并没有学习到遥感图的任何特征。后来我换了一个分辨率较低的数据集，用了海岸线的数据集，生成的图像正常。这应该是由于特征太少导致的。<br>但是正如前面失败的实验，正常的遥感图不可能只要那么简单的特征。后来我上网搜索，几乎所有尝试复现的中文资料都表明遥感图的GAN实验结果是不理想的。我又尝试模仿<code>StyleGAN</code>（该模型是英伟达专为人脸的生成打造的，在人脸的生成方面数一数二），用全连接层替换了<code>DCGAN</code>中的卷积层，但是实验效果仍不理想（跟之前一样是噪声但是模型仍然收敛）。<br><a href="https://arxiv.org/abs/1912.04958">Karras, T., Laine, S., Aittala, M., Hellsten, J., Lehtinen, J., and Aila, T., “Analyzing and Improving the Image Quality of StyleGAN”, <i>arXiv e-prints</i>, 2019.</a><br>后来我改变了思路，推测出一种可能，那就是一般的卷积无法处理遥感图像这种具有复杂特征的数据。我将目光转向了<code>Transformer</code>，也就是注意力机制，它不依赖任何卷积，我期望它能够在我之后的实验中起到一个比较好的效果。但是由于我对注意力机制不太熟悉，有花了一段时间研究了一下<code>ViTGAN</code>和<code>TransGAN</code>，这两个都是将 <code>Transformer</code> 加入 <code>GAN</code> 的网络。<br><a href="https://arxiv.org/abs/2107.04589">Lee, K., Chang, H., Jiang, L., Zhang, H., Tu, Z., and Liu, C., “ViTGAN: Training GANs with Vision Transformers”, <i>arXiv e-prints</i>, 2021.</a><br><a href="https://arxiv.org/abs/2102.07074">Jiang, Y., Chang, S., and Wang, Z., “TransGAN: Two Pure Transformers Can Make One Strong GAN, and That Can Scale Up”, <i>arXiv e-prints</i>, </a><br><em>在这一步我们甚至可以大胆假设，能不能不光在<code>GAN</code>中引入注意力机制，甚至在整个对抗生成网络中都使用<code>Transformer</code>？</em></p></blockquote><h3 id="方案2">方案2</h3><h4 id="主要内容-2">主要内容</h4><p>将水印隐藏在噪声中，向图像叠加噪声，使人眼无法识别。<br>有文献提出，将水印识别单独置一个 <code>private network</code> ，与发布网络 <code>public network</code> 相隔离。这样我们在识别水印时只要调用 <code>private network</code> 即可。我认为相比起图像里包含的显式特征，想要学习噪声这种隐式特征是尤为困难的。这本质上类似于神经网络的特征过拟合。<br>为了使这种过拟合现象明显一些（这正是我们需要的），就不能使用普通的噪声。有一种噪声（包括但不限于噪声，可以是任何信号甚至pattern）专为实现这种目的而存在，即<strong>对抗样本攻击</strong>。我们只需要对遥感数据做一次对抗样本攻击，即可使图像分类的 <code>softmax</code> 产生较大的改变（即误分类）。我们这时就可以设置一个新的类，比如 <code>watermark</code> ，使所有经过对抗样本攻击的遥感图像被分类为 <code>watermark</code> 。<br><img src="/legacy/imgs/6bc12d07df84d108676ed0d8dcc192c9.jpg" alt=""></p><blockquote><p><a href="https://arxiv.org/abs/1910.13222">Chen, L., Zhu, G., Li, Q., and Li, H., “Adversarial Example in Remote Sensing Image Recognition”, <i>arXiv e-prints</i>, 2019.</a>（遥感图像识别中的对抗性实例）<br>到这个地步，这个方向的目的已经十分明显了：这就是鲁棒性的对抗。<br>对于目标网络来说，要保证目标识别的鲁棒性（即<code>CNN</code>的鲁棒性）；作为隐藏信息，嵌入水印的一方，要保证自己水印的鲁棒性，要保证自己生成的对抗性样本能够抵御各种攻击。<br><em>可能的防御手段：用魔法打败魔法。假如这里有若干张待识别的遥感图像，你不知道其中有没有对抗性样本，同时你对你的<code>CNN</code>网络不太自信，这时候只需要在前面加上一层<code>GAN</code>网络。因为高频的水印（噪声）信息不太可能被<code>GAN</code>所识别到，并且在生成的网络中复现。对于采用了注意力机制的<code>GAN</code>如上面提到的<code>TransGAN</code>与<code>ViTGAN</code>尤其如此。</em></p></blockquote><h4 id="困难-疑惑">困难&amp;疑惑</h4><ul><li>使用对抗样本攻击所生成的噪声为空间域噪声，鲁棒性不佳；</li><li>此方法致力于使判别网络产生误判，从而将图像置于<em>Watermark</em>类，只能起到标记的作用。<br>假如仅仅是这样，为何不直接用加水印的照片与未加水印的照片训练一个<em>Network</em>专门由于分类加了水印的图片呢？<blockquote><p>忘了哪一篇了</p></blockquote></li><li>此方法只能应用于地物分类模型<br>这个算自适应吗？他跟普通图像的处理流程有什么不同呢？步骤必须有意义，比方说遥感图加了一个处理步骤，或者用了一种新的处理方法后，比使用通用图像的处理方法处理后效果要好，etc。</li></ul><h4 id="实验结果">实验结果</h4><blockquote><p><a href="https://colab.research.google.com/drive/15l7f5sECpimhRFCaxXhgjowr3-cWTTsF">基于FGSM的对抗样本实例</a></p></blockquote><h2 id="水印（Watermark）">水印（Watermark）</h2><h3 id="传统方法">传统方法</h3><ul><li>基于空间域的水印（鲁棒性不强）</li><li>基于频率域，如傅里叶，小波，DCT的水印算法</li></ul><blockquote><p><a href="https://ieeexplore.ieee.org/document/9136707">W. Chen, C. Zhu, N. Ren, T. Seppänen and A. Keskinarkaus, “Screen-Cam Robust and Blind Watermarking for Tile Satellite Images,” in IEEE Access, vol. 8, pp. 125274-125294, 2020, doi: 10.1109/ACCESS.2020.3007689.</a></p></blockquote><h3 id="攻击方法">攻击方法</h3><ul><li>旋转</li><li>裁剪，拼接</li><li>重采样（缩放）</li><li>滤波（中值，均值，高斯）</li><li>噪声（椒盐，高斯）</li><li>投影变换</li><li>Screen-Cam Robust<br><em>必须有一种有效的定位手段，确认水印在图像的哪一部分。</em></li></ul><blockquote><p>难道就没有一种水印他的信息是与其完整性无关的吗？即只要拿到水印的任意部分都能完整的还原出信息。<br>遥感图一般是以瓦片Tile的形式存在，当前的图像过大或者过小都会自动切换到上一级或下一级显示。</p></blockquote><h3 id="目前方向">目前方向</h3><h4 id="水印同步-Synchronization-Watermark">水印同步(Synchronization Watermark)</h4><blockquote><p>基于CNN定位精度，Robust</p></blockquote><h4 id="水印提取-Watermark-Extraction">水印提取(Watermark Extraction)</h4><blockquote><p>基于CNN/DNN的判读法</p></blockquote><h4 id="水印嵌入">水印嵌入</h4><blockquote><p>Pattern + Image 基于感知与Robust<br><a href="https://dl.acm.org/doi/abs/10.1145/3503161.3548139">You, Zhengxin, et al. “Image Generation Network for Covert Transmission in Online Social Network.” <em>Proceedings of the 30th ACM International Conference on Multimedia</em>. 2022.</a> 将CelebA换成GID训练遥感地块的Pattern来生成水印。</p></blockquote><h2 id="遥感数据的图像生成">遥感数据的图像生成</h2><p>最近把<strong>遥感数据GAN的实验结果</strong>整理出来，现在做成什么样就什么样。要明确现在<strong>实验数据</strong>、GAN是否<strong>调参</strong>过，生成数据的结果，目前的最新的相关论文大概是什么样。<br>目前的图像生成方法主要有：</p><ul><li>GANs: DCGAN, StyleGAN, WGAN</li><li>VAEs: VQ-VAE, Beta-VAE, FactorVAE</li><li>Augoregressive Models: PixelCNN</li><li>Diffusion Models: DDPM<br>目前对抗生成网络在遥感方面的应用</li><li>遥感图超分辨率</li><li>遥感图像分类</li><li>伪遥感图的生成<br>DCGAN实验发现效果不理想<br>然后尝试使用Transformer模型代替传统卷积。</li></ul><h4 id="实验结果-2">实验结果</h4><h5 id="2022年9月22日-22-28">2022年9月22日 22:28</h5><p><img src="/legacy/imgs/cd51eb3ad5daf1eb1e0f1d73839b204f.png" alt="DCGAN in Remote Sense Images"></p><blockquote><p><em>总结</em> ：</p><p>需加大Epoch数。但由于数据集过小，很难训练出一个很好的模型。实验证明，只要合理调整参数，<code>DCGAN</code>一样可以生成很好的伪遥感图…</p><p>至于为什么上学期的实验总是不成功，我觉得可能的原因有：</p><ol><li>上学期的实验主要使用了<code>Tensorflow</code>，而且本学期换用了<code>Pytorch</code>；</li><li>上学期参数调得不好，训练了很多轮但是效果总是不好，误认为传统的<code>CNN</code>网络做不了遥感；</li><li>玄学问题（大虚。</li></ol></blockquote><h5 id="2022年9月13日">2022年9月13日</h5><p><img src="/legacy/imgs/ce41fcdfc8bb49334e814c06e3d88eaf.png" alt="Generator and Discriminator Loss"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题可以分成两部分解决：&lt;strong&gt;自适应&lt;/strong&gt;与&lt;strong&gt;水印&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://blog.lotusmomo.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>反爬虫的极致手段——利用Gzip压缩炸弹</title>
    <link href="https://blog.lotusmomo.cn/2022/08/01/anti-spidering-gzip-bomb/"/>
    <id>https://blog.lotusmomo.cn/2022/08/01/anti-spidering-gzip-bomb/</id>
    <published>2022-08-01T15:27:00.000Z</published>
    <updated>2022-08-01T16:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个站长，你一定对爬虫恨之入骨。爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费而不给你创造任何收益。本文假设你已经知道某个请求是爬虫发来的了，你不满足于单单屏蔽对方，而是想搞死对方。</p><span id="more"></span><p>很多人的爬虫是使用Requests来写的，如果你阅读过Requests的文档，那么你可能在文档中的常见问题看到这样一段文字：</p><blockquote><p>Requests 自动解压缩的 <code>gzip</code> 编码的响应体，并在可能的情况下尽可能的将响应内容解码为 <code>unicode</code>。</p><p>如果需要的话，你可以直接访问原始响应内容（甚至是套接字）。</p></blockquote><p>网站服务器可能会使用<code>gzip</code>压缩一些大资源，这些资源在网络上传输的时候，是压缩后的二进制格式。客户端收到返回以后，如果发现返回的<code>Headers</code>里面有一个字段叫做<code>Content-Encoding</code>，其中的值包含<code>gzip</code>，那么客户端就会先使用<code>gzip</code>对数据进行解压，解压完成以后再把它呈现到客户端上面。在浏览器上，这完全是一个自动化的过程，用户是感知不到这个事情发生的。而<code>Requests</code>，<code>Scrapy</code>这种网络请求库或者爬虫框架，也会帮你做这个事情，因此你不需要手动对网站返回的数据解压缩。这原本是帮助服务器节省流量开支的行为，但是利用这个特性，我们同样可以做到反爬虫。</p><p>我们首先写一个客户端，来测试一下返回<code>gzip</code>压缩数据的方法。<br>我首先在硬盘上创建一个文本文件<code>text.txt</code>，里面有两行内容，如下图所示：</p><p><img src="/legacy/imgs/2938691791.png" alt="cat_test_txt.png"></p><p>然后使用<code>gzip</code>命令把它压缩成一个<code>.gz</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.txt| gzip &gt; data.gz</span><br></pre></td></tr></table></figure><p>接下来，我们使用<code>FastAPI</code>写一个HTTP服务器<code>server.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="comment"># save-as: server.py</span></span><br><span class="line"><span class="comment"># Requirements:</span></span><br><span class="line"><span class="comment"># python3 -m pip install fastapi uvicorn</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line">app = FastAPI()</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    resp = FileResponse(<span class="string">&#x27;data.gz&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>然后使用命令<code>uvicorn server:app</code>启动这个服务。<br>接下来，我们使用requests来请求这个接口，会发现返回的数据是乱码，如下图所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="comment"># save-as req.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>).text</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p><img src="/legacy/imgs/3430014703.png" alt="cat_test_txt.png"></p><p><img src="/legacy/imgs/205120399.png" alt="fastapi_log_messy.png"></p><p>返回的数据是乱码，这是因为服务器没有告诉客户端，这个数据是<code>gzip</code>压缩的，因此客户端只有原样展示。由于压缩后的数据是二进制内容，强行转成字符串就会变成乱码。<br>现在，我们稍微修改一下<code>server.py</code>的代码，通过<code>Headers</code>告诉客户端，这个数据是经过<code>gzip</code>压缩的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="comment"># save-as: server_gzip.py</span></span><br><span class="line"><span class="comment"># Requirements:</span></span><br><span class="line"><span class="comment"># python3 -m pip install fastapi uvicorn</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line">app = FastAPI()</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    resp = FileResponse(<span class="string">&#x27;data.gz&#x27;</span>)</span><br><span class="line">    resp.headers[<span class="string">&#x27;Content-Encoding&#x27;</span>] = <span class="string">&#x27;gzip&#x27;</span>  <span class="comment"># 说明这是gzip压缩的数据</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>再使用命令<code>uvicorn server_gzip:app</code>启动这个服务，再次使用requests请求，发现已经可以正常显示数据了：</p><p><img src="/legacy/imgs/2546853461.png" alt="res_good.png"></p><p><img src="/legacy/imgs/546238108.png" alt="fastapi_log_good.png"></p><p>这个功能已经展示完了，那么我们怎么利用它呢？这就不得不提到压缩文件的原理了。<br>文件之所以能压缩，是因为里面有大量重复的元素，这些元素可以通过一种更简单的方式来表示。压缩的算法有很多种，其中最常见的一种方式，我们用一个例子来解释。假设有一个字符串，它长成下面这样</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br><span class="line">0000000000000000</span><br></pre></td></tr></table></figure><p>我们可以用5个字符来表示：<code>0*128</code>。这就相当于把128个字符压缩成了5个字符，压缩率高达96.1%。</p><blockquote><p>这种利用信息熵极低的数据生成的压缩率极高且解压后数据量极大的压缩包被称为压缩炸弹(Zip Bomb)，比较著名的有<code>42.zip</code>，<a href="https://unforgettable.dk/">下载地址</a>。大致内容如下：</p><blockquote><p>The file contains 16 zipped files, which again contains 16 zipped files, which again contains 16 zipped files, which again contains 16 zipped, which again contains 16 zipped files, which contain 1 file, with the size of 4.3GB.<br>So, if you extract all files, you will most likely run out of space :-)<br>16 x 4294967295       = 68.719.476.720 (68GB)<br>16 x 68719476720      = 1.099.511.627.520 (1TB)<br>16 x 1099511627520    = 17.592.186.040.320 (17TB)<br>16 x 17592186040320   = 281.474.976.645.120 (281TB)<br>16 x 281474976645120  = 4.503.599.626.321.920 (4,5PB)</p><p>Password: 42</p></blockquote><p>压缩文件本身大小<code>42KB</code>这个文件用密码42解压之后，会得到16个压缩文件，然后每个文件解压又会出现16个压缩文件，继续每个文件解压又会得到16个压缩文件，循环5次，最终得到1048576个文件，每个最终文件大小为<code>4.3GB</code>，总共<code>4.5PB</code>。<br>如果我们可以把一个1GB的文件压缩成1MB，那么对服务器来说，仅仅是返回了1MB的二进制数据，不会造成任何影响。但是对客户端或者爬虫来说，它拿到这个1MB的数据以后，就会在内存中把它解压成1GB的内容。<br>这样一瞬间爬虫占用的内存就增大了1GB。如果我们再进一步增大这个原始数据，那么很容易就可以把爬虫所在的服务器内存全部沾满，轻者服务器直接杀死爬虫进程，重则爬虫服务器直接死机。<br>这个压缩比听起来很夸张，其实我们使用很简单的一行命令就可以生成这样的压缩文件。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1M count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p><img src="/legacy/imgs/883190545.png" alt="boom_gzip.png"></p><p>生成的这个<code>boom.gz</code>文件只有994KB。但是如果我们使用<code>gzip -d boom.gz</code>对这个文件解压缩，就会发现生成了一个1GB的<code>boom</code>文件，如下图所示：</p><p><img src="/legacy/imgs/3574187962.png" alt="real_boom.png"></p><p>只要大家把命令里面的<code>count=1000</code>改成一个更大的数字，就能得到更大的文件。<br>我现在把<code>count</code>改成10，给大家做一个实验。生成的<code>boom.gz</code>只有10KB：</p><p><img src="/legacy/imgs/1400469115.png" alt="little_boom.png"></p><p>服务器返回一个10KB的二进制数据，没有任何问题。<br>现在我们用<code>requests</code>去请求这个接口，然后查看一下<code>res</code>这个对象占用的内存大小：</p><p><img src="/legacy/imgs/1893723029.png" alt="size_of_boom.png"></p><p>由于<code>requests</code>自动会对返回的数据解压缩，因此最终获得的<code>res</code>对象竟然有10MB这么大。<br>如果大家想使用这个方法来反爬虫，一定要先确定这个请求是爬虫发的。否则被你干死的不是爬虫而是真实用户就麻烦了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个站长，你一定对爬虫恨之入骨。爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费而不给你创造任何收益。本文假设你已经知道某个请求是爬虫发来的了，你不满足于单单屏蔽对方，而是想搞死对方。&lt;/p&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>我们是怎么发现C++异常从堆栈追踪中消失的原因的</title>
    <link href="https://blog.lotusmomo.cn/2022/07/30/cpp-stack-tracing/"/>
    <id>https://blog.lotusmomo.cn/2022/07/30/cpp-stack-tracing/</id>
    <published>2022-07-30T08:51:00.000Z</published>
    <updated>2022-08-01T15:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>每当我的程序崩溃的时候，我都会用核心转储 (core dump) 文件来找出来崩溃发生的具体位置。（关于怎么产生和使用核心转储可以看<a href="#">我的文章</a>。）一直以来我调程序的时候都是很开心的……直到我遇到了这个新的 bug。当我把它的核心转储文件载入到 GDB 之后，我很失望地发现所有的堆栈追踪 (stack trace) 都是关于系统库的，没有一行是关于我的代码的。</p><span id="more"></span><blockquote><p>TLDR: <a href="https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/src/c%2B%2B11/thread.cc?r1=249130&amp;r2=249129&amp;pathrev=249130">这个补丁</a>就好了。</p></blockquote><p>让我们踏上探索未知的旅程吧。</p><h1>背景介绍</h1><p>为了帮助我亲爱的读者朋友们理解我日常的调程序过程，让我们来看看这个简短的 C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile with:</span></span><br><span class="line"><span class="comment">//   g++ -g -std=c++11 sigsegv.cc -o sigsegv -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">100</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，这里应该要有一个段错误 (segmentation fault)。想要知道哪里触发了段错误，如果这个问题不是很容易触发的话，你可以把核心转储文件载入到 GDB 里面，或者如果这个问题很容易重现的话，你也可以直接在 GDB 里面重新跑一遍。那这里就让我们直接在 GDB 里面跑一遍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb ./sigsegv</span></span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Reading symbols from ./sigsegv...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /tmp/sigsegv</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">[New Thread 0x7ffff6f4e700 (LWP 68189)]</span><br><span class="line"></span><br><span class="line">Thread 2 &quot;sigsegv&quot; received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to Thread 0x7ffff6f4e700 (LWP 68189)]</span><br><span class="line">0x0000000000400f5d in foo () at sigsegv.cc:8</span><br><span class="line">8        std::cout &lt;&lt; v[100] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000000000400f5d <span class="keyword">in</span> foo () at sigsegv.cc:8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00000000004027dd <span class="keyword">in</span> std::_Bind_simple&lt;void (*())()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;) (this=0x617c48)</span></span><br><span class="line">    at /usr/include/c++/5/functional:1531</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000000000402736 <span class="keyword">in</span> std::_Bind_simple&lt;void (*())()&gt;::operator()() (this=0x617c48)</span></span><br><span class="line">    at /usr/include/c++/5/functional:1520</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00000000004026c6 <span class="keyword">in</span> std::thread::_Impl&lt;std::_Bind_simple&lt;void (*())()&gt; &gt;::_M_run() (this=0x617c30)</span></span><br><span class="line">    at /usr/include/c++/5/thread:115</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007ffff7b0dc80 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00007ffff76296ba <span class="keyword">in</span> start_thread (arg=0x7ffff6f4e700) at pthread_create.c:333</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x00007ffff735f41d <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span></span><br></pre></td></tr></table></figure><p>可以看到，GDB 一如既往能够显示出来是在我们代码中的哪一行崩溃的。<br>到目前为止一切正常。但是在这一次的 bug 里面，我的代码用了 <a href="https://en.cppreference.com/w/cpp/container/vector/at">vector::at</a> 来访问数组元素。如果访问越界，它会抛出 <code>std::out_of_range</code> 异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile with:</span></span><br><span class="line"><span class="comment">//   g++ -g -std=c++11 exception.cc -o exception -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    std::cout &lt;&lt; v.<span class="built_in">at</span>(<span class="number">100</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来使用 at 是一个比 operator[] 更安全的写法。然而，这一次 GDB 却不会告诉我程序在哪里崩溃了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb ./exception</span></span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Reading symbols from ./exception...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /tmp/exception</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">[New Thread 0x7ffff6f4e700 (LWP 68143)]</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  vector::_M_range_check: __n (which is 100) &gt;= this-&gt;size() (which is 0)</span><br><span class="line"></span><br><span class="line">Thread 2 &quot;exception&quot; received signal SIGABRT, Aborted.</span><br><span class="line">[Switching to Thread 0x7ffff6f4e700 (LWP 68143)]</span><br><span class="line">0x00007ffff728d428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">54    ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff728d428 <span class="keyword">in</span> __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff728f02a <span class="keyword">in</span> __GI_abort () at abort.c:89</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7ae484d <span class="keyword">in</span> __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7ae26b6 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007ffff7ae2701 <span class="keyword">in</span> std::terminate() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00007ffff7b0dd38 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x00007ffff76296ba <span class="keyword">in</span> start_thread (arg=0x7ffff6f4e700) at pthread_create.c:333</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00007ffff735f41d <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span></span><br></pre></td></tr></table></figure><p>乍一看一切正常，我的程序在临死之前告诉我 vector 抛出了 std::out_of_range 异常。我简直被我的程序感动了。但是我想知道具体是那哪里抛出了异常。<br>让我们看看这个堆栈追踪，里面竟然没有一行是我的代码。虽然说在这个例子里面，直接看一眼代码你就可以看出来问题出现在哪里了，但是在我真正的项目里面有1万行 C++ 代码，我真的需要 GDB 来告诉我具体是在哪一行出了问题。<br>现在你应该明白为什么我对这个事情这么执着了。</p><h2 id="系统库里面有-Bug？">系统库里面有 Bug？</h2><p>坐在我边上的哥们 Niel 告诉我这有可能是因为底层的库里面有 bug。<br>说实话，我一般来说不相信编译器、操作系统或者底层库会出现大到足以影响到我日常使用的 bug。我觉得这几乎是不可能发生的事情，因为这些都是广泛使用的基础设施。<br>但是 Niel 说他以前有遇到过底层库的 bug，而且他说他愿意帮我看一下这个问题，而且他人又超级好的，所以我们就一起开始看这个问题了。</p><h2 id="恢复-符号">恢复 ?? 符号</h2><p>盯着 GDB 里面的 ?? 符号看是不会有任何帮助的。所以我决定把这些符号的名字找出来。我自以为我对 Ubuntu 已经有了足够的了解，所以我很自然地就打出来了 <code>sudo apt install libstdc++-gdb</code>。然而这个包并不存在。我花了点时间才找到了这个包正确的名字叫做 libstdc++6-5-dbg，其中6对应了 libstdc++.so.6，5指的是 GCC 5.4，因为我用的是 Ubuntu 16.04。<br>在安装好了调试符号之后，GDB 就给了我们更多的线索：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb ./exception</span></span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Reading symbols from ./exception...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /tmp/exception</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">[New Thread 0x7ffff6f4e700 (LWP 68314)]</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  vector::_M_range_check: __n (which is 100) &gt;= this-&gt;size() (which is 0)</span><br><span class="line"></span><br><span class="line">Thread 2 &quot;exception&quot; received signal SIGABRT, Aborted.</span><br><span class="line">[Switching to Thread 0x7ffff6f4e700 (LWP 68314)]</span><br><span class="line">0x00007ffff728d428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">54    ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff728d428 <span class="keyword">in</span> __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff728f02a <span class="keyword">in</span> __GI_abort () at abort.c:89</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7ae484d <span class="keyword">in</span> __gnu_cxx::__verbose_terminate_handler ()</span></span><br><span class="line">    at ../../../../src/libstdc++-v3/libsupc++/vterminate.cc:95</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7ae26b6 <span class="keyword">in</span> __cxxabiv1::__terminate (handler=&lt;optimized out&gt;)</span></span><br><span class="line">    at ../../../../src/libstdc++-v3/libsupc++/eh_terminate.cc:47</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007ffff7ae2701 <span class="keyword">in</span> std::terminate () at ../../../../src/libstdc++-v3/libsupc++/eh_terminate.cc:57</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00007ffff7b0dd38 <span class="keyword">in</span> std::execute_native_thread_routine (__p=&lt;optimized out&gt;)</span></span><br><span class="line">    at ../../../../../src/libstdc++-v3/src/c++11/thread.cc:92</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x00007ffff76296ba <span class="keyword">in</span> start_thread (arg=0x7ffff6f4e700) at pthread_create.c:333</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00007ffff735f41d <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span></span><br></pre></td></tr></table></figure><h1>Glibc</h1><p>我们决定跟着堆栈追踪从底向上地一层一层看过去。clone() 听起来并不十分有趣，所以我们就跳过了它。所以我们现在要看的是 pthread_create.c:333。一番搜索之后，我意识到了它是在 glibc 里面的。但是我用的是哪个版本的 glibc 呢？我的想法是用 ldd 先把 .so 文件找出来：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd ./exception</span></span><br><span class="line">    linux-vdso.so.1 =&gt;  (0x00007ffc77f54000)</span><br><span class="line">    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f23ae730000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f23ae51a000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f23ae150000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f23ade47000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f23aeab2000)</span><br></pre></td></tr></table></figure><p>现在我们知道 .so 文件在哪里了，那具体是哪个版本呢？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -la /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 Mar  4 18:36 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.23.so</span><br></pre></td></tr></table></figure><p>好了，现在我们就可以在 glibc 2.23 的源代码里面看一眼 <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=nptl/pthread_create.c;h=521604173325fdc222599f2902f4c1d796b8ef5d;hb=refs/heads/release/2.23/master#l333">pthread_create.c:333</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREAD_SETMEM (pd, result, CALL_THREAD_FCT (pd));  <span class="comment">// pthread_create.c:333</span></span><br></pre></td></tr></table></figure><p>现在我想知道 <code>CALL_THREAD_FCT</code> 是做什么的，这看起来像是一个宏，我得找到这个宏的定义：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&#x27;#define CALL_THREAD_FCT&#x27;</span> -r glibc-2.23</span></span><br><span class="line">glibc-2.23/sysdeps/i386/nptl/tls.h:#define CALL_THREAD_FCT(descr) \</span><br></pre></td></tr></table></figure><p>很幸运的是，这个符号真的是用 <code>#define CALL_THREAD_FCT</code> 定义出来的，但不幸的是我找到的结果跟我的机器并不是一个架构。但又非常幸运的是，我成功地猜到了我想要的在 <code>glibc-2.23/sysdeps/x86_64/nptl/tls.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_THREAD_FCT(descr) \</span></span><br><span class="line"><span class="meta">  (&#123; void *__res;                                                             \</span></span><br><span class="line"><span class="meta">     asm volatile (<span class="string">&quot;movq %%fs:%P2, %%rdi\n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;callq *%%fs:%P1&quot;</span>                                          \</span></span><br><span class="line"><span class="meta">                   : <span class="string">&quot;=a&quot;</span> (__res)                                             \</span></span><br><span class="line"><span class="meta">                   : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, start_routine)),          \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, arg))                     \</span></span><br><span class="line"><span class="meta">                   : <span class="string">&quot;di&quot;</span>, <span class="string">&quot;si&quot;</span>, <span class="string">&quot;cx&quot;</span>, <span class="string">&quot;dx&quot;</span>, <span class="string">&quot;r8&quot;</span>, <span class="string">&quot;r9&quot;</span>, <span class="string">&quot;r10&quot;</span>, <span class="string">&quot;r11&quot;</span>,        \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>);                                         \</span></span><br><span class="line"><span class="meta">     __res; &#125;)</span></span><br></pre></td></tr></table></figure><p>我不太懂汇编，这看起来像是在调用 start_routine 并把 args 作为参数传进去。看起来也不是很有趣。<br>我们决定看一下下一层调用堆栈。</p><h2 id="libstdc">libstdc++</h2><p>所以说我们需要找到 libstdc++ 的源代码。我意识到 libstdc++ 其实是 GCC 的一部分，所以说我们需要的是 GCC 5.4 的源代码。让我们看一看 <code>../../../../../src/libstdc++-v3/src/c++11/thread.cc:92</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>*</span></span><br><span class="line"><span class="function">  <span class="title">execute_native_thread_routine</span><span class="params">(<span class="type">void</span>* __p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    thread::_Impl_base* <span class="type">__t</span> = <span class="built_in">static_cast</span>&lt;thread::_Impl_base*&gt;(__p);</span><br><span class="line">    thread::__shared_base_type __local;</span><br><span class="line">    __local.<span class="built_in">swap</span>(<span class="type">__t</span>-&gt;_M_this_ptr);</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">__t</span>-&gt;_M_run();</span><br><span class="line">      &#125;</span><br><span class="line">    __catch(<span class="type">const</span> __cxxabiv1::__forced_unwind&amp;)</span><br><span class="line">      &#123;</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">      &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">      &#123;</span><br><span class="line">        std::<span class="built_in">terminate</span>();  <span class="comment">// line 92</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// extern &quot;C&quot;</span></span><br></pre></td></tr></table></figure><p>当我打开这个文件的时候，我已经惊呆了。为什么 libstdc++ 想要捕获所有的异常？！就不能直接让用户程序崩溃吗！<br>这段代码说明了一切。我的代码肯定是跑在 <code>try</code> 代码块里面的。当它抛出一个异常之后，它会被92行的 <code>catch</code> 代码块捕获。但是到了程序的控制流已经被 <code>catch</code> 代码块捕获了的时候，所有的堆栈都已经被展开了 (stack unwind)，所有能帮助我调试程序的信息都被扔掉了。</p><h1>Bug 报告</h1><p>对我来说这看起来可以被称作 libstdc++ 的 bug。我搜索了一下，然后发现有人在2013年就报告了这个 Bug #55917，但是这个问题直到 GCC 8 才被修复。而且补丁本身非常简单，就是把 try-catch 删掉，直接让用户代码崩溃。</p><h2 id="升级到-GCC-8">升级到 GCC 8</h2><p>既然我们知道了这个问题已经在 GCC 8 里面修好了，我们就可以重新把程序用 GCC 8 编译一遍。因为 Ubuntu 16.04 的软件源里面没有包含 GCC 8，所以我们得用 ubuntu-toolchain-r/test PPA:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install g++-8</span><br></pre></td></tr></table></figure><p>现在让我们重新编译一下之前的代码然后放到 GDB 里面试试：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++-8 -g -std=c++11 exception.cc -o exception -pthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb ./exception</span></span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Reading symbols from ./exception...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /tmp/exception</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">[New Thread 0x7ffff6f42700 (LWP 69463)]</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  vector::_M_range_check: __n (which is 100) &gt;= this-&gt;size() (which is 0)</span><br><span class="line"></span><br><span class="line">Thread 2 &quot;exception&quot; received signal SIGABRT, Aborted.</span><br><span class="line">[Switching to Thread 0x7ffff6f42700 (LWP 69463)]</span><br><span class="line">0x00007ffff7281428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">54    ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff7281428 <span class="keyword">in</span> __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff728302a <span class="keyword">in</span> __GI_abort () at abort.c:89</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff7ad78f7 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007ffff7adda46 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007ffff7adda81 <span class="keyword">in</span> std::terminate() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00007ffff7addcb4 <span class="keyword">in</span> __cxa_throw () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x00007ffff7ad97f5 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x0000000000401274 <span class="keyword">in</span> std::vector&lt;int, std::allocator&lt;int&gt; &gt;::_M_range_check (this=0x7ffff6f41e00, __n=100)</span></span><br><span class="line">    at /usr/include/c++/8/bits/stl_vector.h:960</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  0x0000000000401033 <span class="keyword">in</span> std::vector&lt;int, std::allocator&lt;int&gt; &gt;::at (this=0x7ffff6f41e00, __n=100)</span></span><br><span class="line">    at /usr/include/c++/8/bits/stl_vector.h:981</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9  0x0000000000400dd7 <span class="keyword">in</span> foo () at exception.cc:8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 0x00000000004013a7 <span class="keyword">in</span> std::__invoke_impl&lt;void, void (*)()&gt;(std::__invoke_other, void (*&amp;&amp;)()) (</span></span><br><span class="line">    __f=&lt;unknown type in /tmp/exception, CU 0x0, DIE 0x6a01&gt;) at /usr/include/c++/8/bits/invoke.h:60</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0x0000000000401093 <span class="keyword">in</span> std::__invoke&lt;void (*)()&gt;(void (*&amp;&amp;)()) (__fn=&lt;unknown <span class="built_in">type</span> <span class="keyword">in</span> /tmp/exception, CU 0x0, DIE 0x6e68&gt;)</span></span><br><span class="line">    at /usr/include/c++/8/bits/invoke.h:95</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0x00000000004019da <span class="keyword">in</span> std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x615c28)</span></span><br><span class="line">    at /usr/include/c++/8/thread:234</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13 0x000000000040199b <span class="keyword">in</span> std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x615c28)</span></span><br><span class="line">    at /usr/include/c++/8/thread:243</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">14 0x0000000000401970 <span class="keyword">in</span> std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x615c20)</span></span><br><span class="line">    at /usr/include/c++/8/thread:186</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">15 0x00007ffff7b0857f <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16 0x00007ffff761d6ba <span class="keyword">in</span> start_thread (arg=0x7ffff6f42700) at pthread_create.c:333</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">17 0x00007ffff735341d <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span></span><br></pre></td></tr></table></figure><p>注意看堆栈9，里面就是我们的代码！问题解决了！</p><h1>经验教训</h1><p>尽管底层的软件和库自身的问题影响到一般的程序的可能性很低，但它确实发生了，而且未来还有可能继续发生。所以说，不要害怕去深入底层看一看。<br>最后再次感谢 Niel 老哥。要不是有他帮我，我肯定不会深挖这个问题的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每当我的程序崩溃的时候，我都会用核心转储 (core dump) 文件来找出来崩溃发生的具体位置。（关于怎么产生和使用核心转储可以看&lt;a href=&quot;#&quot;&gt;我的文章&lt;/a&gt;。）一直以来我调程序的时候都是很开心的……直到我遇到了这个新的 bug。当我把它的核心转储文件载入到 GDB 之后，我很失望地发现所有的堆栈追踪 (stack trace) 都是关于系统库的，没有一行是关于我的代码的。&lt;/p&gt;</summary>
    
    
    
    <category term="程序人生" scheme="https://blog.lotusmomo.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>为PVE虚拟机启用XTerm登录</title>
    <link href="https://blog.lotusmomo.cn/2022/07/22/xterm-pve-guests/"/>
    <id>https://blog.lotusmomo.cn/2022/07/22/xterm-pve-guests/</id>
    <published>2022-07-22T12:00:00.000Z</published>
    <updated>2022-07-23T06:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在PVE中新建虚拟机后，在web界面默认的连接方式是novnc，无法进行复制粘贴等操作。但是如果我们新建的是LXD容器，默认的登陆方法是通过<code>XTerm.js</code>，可以进行复制粘贴等操作。本文将主要介绍如何为PVE虚拟机启用XTerm登录。</p><span id="more"></span><p><img src="vnc.png" alt="vnc"></p><p>进入PVE的web管理界面，选中需要操作的虚拟机，添加串行端口<code>serial0</code>。</p><p><img src="serial.png" alt="serial"></p><p>重启虚拟机，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>将<code>GRUB_CMDLINE_LINUX=&quot;&quot;</code>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;quiet console=tty0 console=ttyS0,115200&quot;</span></span><br></pre></td></tr></table></figure><p>如果是Debian系的，如Ubuntu，Debian，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><p>如果是Redhat系的，如RHEL，CentOS，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig --output=/boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p><img src="xtermjs.png" alt="xtermjs"></p><p>重启，在“控制台”菜单选择“xterm.js”。</p><p><img src="tty.png" alt="tty"></p><p>XTerm已经可以通过<code>ttyS0</code>正常登录了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在PVE中新建虚拟机后，在web界面默认的连接方式是novnc，无法进行复制粘贴等操作。但是如果我们新建的是LXD容器，默认的登陆方法是通过&lt;code&gt;XTerm.js&lt;/code&gt;，可以进行复制粘贴等操作。本文将主要介绍如何为PVE虚拟机启用XTerm登录。&lt;/p&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>GPU服务器联网指南</title>
    <link href="https://blog.lotusmomo.cn/2021/12/24/gpu-server-internet/"/>
    <id>https://blog.lotusmomo.cn/2021/12/24/gpu-server-internet/</id>
    <published>2021-12-24T06:22:00.000Z</published>
    <updated>2023-11-21T02:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>高性能计算实验室提供了一台配置了六块<code>NVDIA Tesla T4</code>计算卡的GPU服务器，然而根据学校的相关管理规定，这台服务器并不能访问互联网，具体的说，核心交换机会将所有<code>192.168.102.12</code>发出的<code>TCP[SYN]</code>数据包全部丢弃。这可怎么办？实验室的同学们急坏了，一边骂着“にま的”，一边在寻找着突破封锁的方法。</p><span id="more"></span><p>然而，广大劳动人们的智慧是无穷无尽的。经过我的一番思考，我用反向代理+VPN实现了上网功能，满足了劳动人民的需求，获得了实验室同学们的好评。下面我来介绍这种方法。<br>首先从TCP数据包的封锁突破。既然服务器无法主动发出对外的连接，那么只要一台客户端主机主动发起并保持对服务器的连接，服务器就能访问到客户端。就此我想到了著名的反向代理工具<code>frp</code>可以实现类似的效果。<br>我先用日本筑波大学的开源软件<code>Softether VPN</code>搭建好了VPN服务器，将<code>5555</code>端口作为接受连接的端口。网上教程一抓一大把，再次不再赘述。然后在本地配置<code>frp</code>的客户端，服务器上配置<code>frp</code>的服务端，将<code>5555</code>端口进行穿透。这样，服务器的<code>5555</code>端口实际上已经可以被连接了。<br>最后用<code>ftp</code>将vpn客户端传输到虚拟机上，创建虚拟网卡，新建连接，输入<code>192.168.102.12</code>，端口<code>5555</code>，熟练的打开Chrome，Oh~可以上网了！</p><h2 id="最后公布一些参数">最后公布一些参数</h2><h3 id="快速添加">快速添加</h3><p>本仓库中的<code>yzu-gpu.vpn</code>为配置文件，导入客户端可一键连接。校外连接请使用<code>AliyunPub.vpn</code>。</p><h3 id="frp服务器配置文件"><code>frp</code>服务器配置文件</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">812</span>ba835-<span class="number">4</span>fac-<span class="number">4</span>b08-<span class="number">9441</span>-<span class="number">8</span>b7dcc1bdcb8</span><br><span class="line"><span class="attr">dashboard_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="comment"># dashboard user and passwd for basic auth protect</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br></pre></td></tr></table></figure><h3 id="VPN服务器管理密码">VPN服务器管理密码</h3><p>下载<code>Softether VPN</code>管理工具，连接到服务器<code>192.168.102.12</code>，端口<code>5555</code>，密码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Yzulug@</span><span class="number">114514</span></span><br></pre></td></tr></table></figure><h3 id="VPN密码">VPN密码</h3><p>下载<code>Softether VPN</code>客户端（管理工具也会一同安装），连接到服务器<code>192.168.102.12</code>，端口<code>5555</code>，<br>账号：<code>gpu</code><br>密码：<code>yzuserver</code></p><h3 id="关于获得的ip">关于获得的ip</h3><p>连接VPN后自动获得的ip为我的寝室内网ip，由路由器的DHCP自动分配，为<code>10.10.1.0/24</code>。<br>路由器的ip地址为<code>10.10.1.254</code>，管理用户、密码为<code>admin:Asd123456@</code>，不推荐自行配置。</p><h3 id="关于校外访问">关于校外访问</h3><p>服务同时穿透到阿里云服务器<code>101.132.42.234</code>，方法同上，只需更改ip地址。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高性能计算实验室提供了一台配置了六块&lt;code&gt;NVDIA Tesla T4&lt;/code&gt;计算卡的GPU服务器，然而根据学校的相关管理规定，这台服务器并不能访问互联网，具体的说，核心交换机会将所有&lt;code&gt;192.168.102.12&lt;/code&gt;发出的&lt;code&gt;TCP[SYN]&lt;/code&gt;数据包全部丢弃。这可怎么办？实验室的同学们急坏了，一边骂着“にま的”，一边在寻找着突破封锁的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="程序人生" scheme="https://blog.lotusmomo.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>CentOS下部署Docker</title>
    <link href="https://blog.lotusmomo.cn/2020/03/04/centos-docker-deploy/"/>
    <id>https://blog.lotusmomo.cn/2020/03/04/centos-docker-deploy/</id>
    <published>2020-03-04T01:41:00.000Z</published>
    <updated>2022-08-29T09:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Docker">什么是 Docker</h2><p><strong>Docker</strong> 最初是 <code>dotCloud</code> 公司创始人 <a href="https://github.com/shykes">Solomon Hykes</a> 在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby">GitHub</a> 上进行维护。<code>Docker</code> 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/">开放容器联盟（OCI）</a>。</p><span id="more"></span><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 5 万 4 千个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，<a href="https://www.docker.com/blog/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker</a>。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。<br><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。<br><img src="https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/media/docker-on-linux.png" alt="Docker 架构">图 1.4.1.1 - Docker 架构</p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec">OCI容器运行时规范</a> 创建和运行容器。</p><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。<br><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。<br>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-6e94771ad01da3cb20e2190b01dfa54e3a69d0b2%2Fvirtualization.png?alt=media" alt="传统虚拟化"><br><img src="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5c1a41d44b8602c8f746e8929f484a701869ca25%2Fdocker.png?alt=media" alt="Docker"><br>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p></blockquote><h2 id="准备工作">准备工作</h2><h3 id="系统要求">系统要求</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p><h3 id="卸载旧版本">卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h2 id="使用-yum-安装">使用 yum 安装</h2><p>执行以下命令安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。<br>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><p>如果需要测试版本的 Docker CE 请使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> docker-ce-test</span><br></pre></td></tr></table></figure><p>如果需要每日构建版本的 Docker CE 请使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum-config-manager --<span class="built_in">enable</span> docker-ce-nightly</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-CE">安装 Docker CE</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum makecache fast</span><br><span class="line">$ <span class="built_in">sudo</span> yum install docker-ce</span><br></pre></td></tr></table></figure><h2 id="使用脚本自动安装">使用脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ <span class="built_in">sudo</span> sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。</p><h2 id="启动-Docker-CE">启动 Docker CE</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ <span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="建立-docker-用户组">建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。<br>建立 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h2 id="测试-Docker-是否安装正确">测试 Docker 是否安装正确</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run hello-world</span></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h2 id="镜像加速">镜像加速</h2><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html">国内镜像加速</a>。</p><h2 id="添加内核参数">添加内核参数</h2><p>如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure><p>请添加内核配置参数以启用这些功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>然后重新加载 <code>sysctl.conf</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Docker&quot;&gt;什么是 Docker&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt; 最初是 &lt;code&gt;dotCloud&lt;/code&gt; 公司创始人 &lt;a href=&quot;https://github.com/shykes&quot;&gt;Solomon Hykes&lt;/a&gt; 在法国期间发起的一个公司内部项目，它是基于 &lt;code&gt;dotCloud&lt;/code&gt; 公司多年云服务技术的一次革新，并于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Docker_(software)&quot;&gt;2013 年 3 月以 Apache 2.0 授权协议开源&lt;/a&gt;，主要项目代码在 &lt;a href=&quot;https://github.com/moby/moby&quot;&gt;GitHub&lt;/a&gt; 上进行维护。&lt;code&gt;Docker&lt;/code&gt; 项目后来还加入了 Linux 基金会，并成立推动 &lt;a href=&quot;https://www.opencontainers.org/&quot;&gt;开放容器联盟（OCI）&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.lotusmomo.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Docker 中产生 Core Dump 文件</title>
    <link href="https://blog.lotusmomo.cn/2020/01/12/docker-core-dump/"/>
    <id>https://blog.lotusmomo.cn/2020/01/12/docker-core-dump/</id>
    <published>2020-01-12T09:14:00.000Z</published>
    <updated>2020-03-08T01:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先简单补充一下 Core Dump 文件可以做什么吧。</p><p>当我们程序崩溃的时候，除了看到 Segmentation Fault 之类的错误信息以外，很有可能在后面还有一句 (core dumped)。以前看到这些字眼都觉得很烦，因为程序崩溃了。但是后来，今年暑假学习的时候，看到学长的操作才恍然大悟，看到 (core dumped) 应该感到高兴才对，因为他把程序崩溃时的运行时信息完完全全地记了下来，包括他的整个内存、所有线程、堆栈信息、寄存器等等……这样一来就给找到 bug 提供了一条很好的线索。</p><span id="more"></span><h1>产生和使用 Core Dump 文件</h1><p>在 Ubuntu 14.04 中，要使得程序崩溃时产生 Core Dump 文件，首先要在 Shell 中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p>然后再去执行我们的程序。这是因为，默认的 ulimit 限制了 Core Dump 文件的大小最大为0，也就是不产生，这里我们改成不限制就行了。<br>之后，如果程序崩溃了，会在当前目录产生一个叫做 core 的文件。我们可以把它载入到 GDB 里面，比方说我们的程序是 ./a.out，那么我们执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./a.out core</span><br></pre></td></tr></table></figure><p>然后我们就能在 GDB 里面看到崩溃时的样子啦！<br>值得注意的是，core 文件不会被覆盖，所以在使用完当前的 core 文件后，记得要把它删掉，否则就看不到下次产生的 Core Dump 了。</p><h2 id="在程序中指定产生-Core-Dump-文件">在程序中指定产生 Core Dump 文件</h2><p>在写程序的时候，我们可能会希望在一些严重错误发生的时候终止程序运行。除了打日志和 exit() 以外，我们还可以选择使用 abort()。当执行 abort() 的时候，程序直接退出，不执行清扫，并且会产生 Core Dump 文件（如果 ulimit 允许的话）。</p><h3 id="在-Docker-中产生-Core-Dump-文件">在 Docker 中产生 Core Dump 文件</h3><p>因为现在家用GPU的虚拟化还没有什么合理的方案，所以我们在开发的时候就把 nvidia-docker 作为虚拟机来用了……后来我发现了一个问题，就是我在 Docker 里面无论如何也无法产生 Core Dump 文件。几经波折，最后终于找到了合理的方法。<br>首先是，我们要在宿主机上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/tmp/core.%t.%e.%p&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>这是因为系统在产生 Core Dump 文件的时候是根据 /proc/sys/kernel/core_pattern 的设定。而默认的设定是 |/usr/share/apport/apport %p %s %c %P，也就是用管道传给 apport。然而 Docker 里面的系统不一定有装 apport，并且 /proc 又是直接挂到 Docker 里面的，所以我们就得改成放到固定的位置去，也就是 /tmp。<br>另外，在 docker run 的时候要加上以下参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="variable">$&#123;IMAGE&#125;</span> --<span class="built_in">ulimit</span> core=-1 --security-opt seccomp=unconfined</span><br></pre></td></tr></table></figure><p>前者就是把 Core Dump 文件的大小设置为无限制，后者是为了开放 ptrace 系列高权限的系统调用，这样我们才可以在 Docker 里面使用 GDB。</p><h1>Reference</h1><ul><li><a href="https://github.com/docker/docker/issues/12515#issuecomment-100624686">https://github.com/docker/docker/issues/12515#issuecomment-100624686</a></li><li><a href="https://github.com/docker/docker/issues/11740#issuecomment-86041679">https://github.com/docker/docker/issues/11740#issuecomment-86041679</a></li><li><a href="https://github.com/docker/docker/issues/11740#issuecomment-222924994">https://github.com/docker/docker/issues/11740#issuecomment-222924994</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先简单补充一下 Core Dump 文件可以做什么吧。&lt;/p&gt;
&lt;p&gt;当我们程序崩溃的时候，除了看到 Segmentation Fault 之类的错误信息以外，很有可能在后面还有一句 (core dumped)。以前看到这些字眼都觉得很烦，因为程序崩溃了。但是后来，今年暑假学习的时候，看到学长的操作才恍然大悟，看到 (core dumped) 应该感到高兴才对，因为他把程序崩溃时的运行时信息完完全全地记了下来，包括他的整个内存、所有线程、堆栈信息、寄存器等等……这样一来就给找到 bug 提供了一条很好的线索。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.lotusmomo.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>macOS 矢量作图小贴士</title>
    <link href="https://blog.lotusmomo.cn/2020/01/12/macos-vector-graphing/"/>
    <id>https://blog.lotusmomo.cn/2020/01/12/macos-vector-graphing/</id>
    <published>2020-01-12T06:11:00.000Z</published>
    <updated>2020-03-08T01:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“放大放大再放大，每一根毛都看的清清楚楚。”<br><a href="https://www.bilibili.com/video/av783">——[欢乐笔记本]内置病毒AIPC笔记本电脑</a></p></blockquote><span id="more"></span><iframe src="https://player.bilibili.com/player.html?aid=783&cid=3738504&as_wide=1" frameborder="no"></iframe><p>前些天我在写论文，自然免不了作图。我相信有很多读者像我一样有这样的强迫症：插图不是矢量图就浑身难受。插矢量图的好处都有啥？</p><ul><li>放大看也不会模糊</li><li>可选中图片中的文字（似乎也没啥用）</li><li>看起来更像是自己画的而不是从网上截图</li></ul><p>LaTeX 作矢量图的一大流派是 tikz，但是这个包对我来说还是太难了，总是学不会。而且我总是觉得，作图这种事情，就应该是在图形化界面里面拖拖点点更加直观清晰。之前我也听说有人用 InkScape、Ipe 等等软件的，但试了一下用起来总是不顺手。<br>可能是因为做幻灯片的机会比作图多得多吧，我发现我对 Keynote 非常习惯，于是理所当然地，我就顺带用 Keynote 来作图了。下面就介绍一下我在 macOS 下面作矢量图的经验，里面也包含了一部分用来做幻灯片的技巧。</p><h1>矢量图格式</h1><p>常见的矢量图格式以及在各种软件的兼容性可以总结成下面的这个表：</p><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">LaTeX</th><th style="text-align:center">Keynote</th><th style="text-align:center">浏览器</th></tr></thead><tbody><tr><td style="text-align:center">.pdf</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">.eps</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">.ps</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">.svg</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">Yes</td></tr></tbody></table><p>既然要用 Keynote 作图，当然要把素材矢量图导入进去啦。对于 .pdf 和 .eps 文件，直接往 Keynote 里面拖就行了。这里介绍一下另外几个实用的小技巧。</p><h2 id="用-Preview-复制-pdf-中的一部分">用 Preview 复制 pdf 中的一部分</h2><p>有时候我们想要引入一个 pdf 的一部分，比方说一幅图或者一个公式。最想当然的方法就是截图了，但截图产生的是位图，一拉伸就糊了。使用 Preview 可以非常方便地把矢量图原样取出来：</p><p><img src="preview-pdf-selection.png" alt="preview-pdf-selection"></p><p>点击搜索栏左边的铅笔标签，可以多出来一个 Markup Toolbar，再点击其中的选取工具，然后选择你需要的部分，按 cmd+c 复制，切换到 Keynote 里面，按 cmd+v 粘贴就行了。</p><p><img src="keynote-pasted-image-pdf.png" alt="keynote-pasted-image-pdf"></p><p>从 Keynote 的侧边栏可以看到，我们粘贴进来的图像是 pdf 格式的，而且可以通过放大缩小来验证，确实是矢量图。<br>另外，如果不想把选区插入 Keynote 而是想直接保存成图片，那么在按 cmd+c 复制选区，点击菜单栏 File / New from Clipboard 或者按 cmd+n，就会创建一个新的图片，按 cmd+s 保存成 pdf 文件就可以插入到 LaTeX 里面了。</p><h2 id="用-Preview-复制一整页-pdf-幻灯片">用 Preview 复制一整页 pdf 幻灯片</h2><p>这个技巧与上面的类似。在制作幻灯片的时候，有时我们想引用别人的整张幻灯片。使用 Preview 这也可以很轻松地做到：</p><p><img src="preview-pdf-page.png" alt="preview-pdf-page"></p><p>点击最左边的视图图标，选中缩略图视角，在左侧会多出来幻灯片的缩略图，点击需要复制的幻灯片，按 cmd+c 复制，按 cmd+v 粘贴到 Keynote 里面就行了。</p><h1>插入数学公式</h1><p>Keynote 作图有个先天的功能性缺失：无法插入数学公式。不过既然可以插入 pdf，这就不是一个问题。MacTeX 套件在安装的时候会顺带安装一个非常好用的小工具，叫做 LaTeXiT。</p><p><img src="keynote-export-640.gif" alt="keynote-export-640"></p><p>写好 LaTeX 公式之后，按 LaTeX it!，等待图片生成好，往 Keynote 里面拖就行了，导出的也是 pdf 格式。</p><p><img src="latexit-import-640.gif" alt="latexit-import-640"></p><p>更厉害的是，还可以反向地拖回来：先在 Keynote 里面选中图片，然后在侧边栏把 pdf 图片的图标拖到 LaTeXiT 窗口里面，公式就回来了，可以方便地对其进行修改。</p><h1>Keynote 导出矢量图</h1><p>用 Keynote 画好之后，可以通过下面的方式导出成矢量图：点击 Keynote 菜单栏 File / Export to / PDF，选择最好的图像质量，然后导出。用 Preview 打开导出的 pdf 文件，然后和前面提到的技巧一样，先复制选区，然后从剪贴板新建图像，再保存成 pdf 就行了。</p><p><img src="keynote-export-640.gif" alt="keynote-export-640"></p><h1>用 Inkscape 转换图像格式</h1><p>有时候，我们从网上下载到的矢量图素材是 .svg 格式的，无法插入到 Keynote 里面。Inkscape 可以帮助我们把图片转成 .eps 格式。首先安装 Homebrew 和 Homebrew Cask，然后用下面的命令就可以一键安装 Inkscape：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --cask install inkscape</span><br></pre></td></tr></table></figure><p>然后用 Inkscape 打开图片，再保存成 .eps 就行了。或者，也可以用下面的命令行一键转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inkscape --export-eps=/path/to/image.eps /path/to/image.svg</span><br></pre></td></tr></table></figure><p>需要注意的是，因为一些bug导致从命令行调用 inkscape 的时候当前工作目录会发生改变，所以说一定要使用绝对路径。</p><h1>Matplotlib 导出矢量图</h1><p>在用 matplotlib 作图的时候，只要指定保存的图片的后缀为 .pdf 就能生成矢量图了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;tmp.pdf&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>在 Jupyter Notebook 上显示矢量图</h1><p>相信大家都很熟悉在 Jupyter Notebook 上面用 Matplotlib 了，但是不知道大家看到画出来那一坨糊糊的东西会不会跟我一样浑身难受。实际上，只要多加一行配置，就能够让 Matplotlib 在 Jupyter Notebook 上面输出矢量图了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = <span class="string">&#x27;svg&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的最后一行指定了输出的格式是 svg，这样浏览器就能为你渲染矢量图了。下面上两张比较图：<br>默认输出 png，不用放大就可以看出糊糊一片了：</p><p><img src="matplotlib-png-640.gif" alt="matplotlib-png-640"></p><p>改成输出svg，放大放大再放大，每一根毛都看得清清楚楚：</p><p><img src="matplotlib-svg-640.gif" alt="matplotlib-svg-640"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“放大放大再放大，每一根毛都看的清清楚楚。”&lt;br&gt;
&lt;a href=&quot;https://www.bilibili.com/video/av783&quot;&gt;——[欢乐笔记本]内置病毒AIPC笔记本电脑&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="奇技淫巧" scheme="https://blog.lotusmomo.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
